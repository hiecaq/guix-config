# -*- org-use-property-inheritance: t; toc-org-max-depth: 4; org-confirm-babel-evaluate: nil; -*-
#+title: hiecaq's guix configuration
#+startup: indent
#+property: header-args :comments org :results silent :mkdirp t

#+toc: headlines 2

* Table of Contents :TOC:noexport:
- [[#introduction][Introduction]]
- [[#system-configuration][System Configuration]]
  - [[#private-info][Private Info]]
  - [[#kernel-firmware-and-initial-ram-disk][Kernel, Firmware and Initial RAM Disk]]
  - [[#bootloader][Bootloader]]
  - [[#file-system][File System]]
    - [[#btrfs-subvolumes][BTRFS subvolumes]]
    - [[#tmp][TMP]]
    - [[#efi][EFI]]
    - [[#device-ids][Device IDs]]
  - [[#users][Users]]
  - [[#packages][Packages]]
  - [[#services][Services]]
    - [[#smart-card][Smart Card]]
    - [[#game-controllers][Game Controllers]]
    - [[#android][Android]]
    - [[#hardware-monitor][Hardware monitor]]
  - [[#default-services-modification][Default Services Modification]]
    - [[#guix][Guix]]
    - [[#gdm][GDM]]
    - [[#audio][Audio]]
- [[#home-configuration][Home Configuration]]
- [[#guix-1][Guix]]
  - [[#locales][Locales]]
  - [[#channels][Channels]]
    - [[#nonguix][Nonguix]]
- [[#cross-desktop-group-xdg][Cross-Desktop Group (XDG)]]
  - [[#base-directories][Base Directories]]
  - [[#user-directories][User Directories]]
- [[#shells][Shells]]
  - [[#fish][Fish]]
  - [[#tools][Tools]]
    - [[#certificates][Certificates]]
    - [[#bat][bat]]
    - [[#eza][eza]]
    - [[#ripgrep][ripgrep]]
    - [[#fd][fd]]
    - [[#direnv][Direnv]]
  - [[#aliases][Aliases]]
- [[#fonts][Fonts]]
- [[#search][Search]]
  - [[#system-service][System service]]
- [[#desktop-environment][Desktop Environment]]
  - [[#display][Display]]
  - [[#status-bar][Status Bar]]
    - [[#amdgpu-temperature-monitor][AmdGPU temperature monitor]]
    - [[#fan-speed-monitor][Fan speed monitor]]
  - [[#d-bus][D-Bus]]
  - [[#xdg-desktop-portal][XDG Desktop Portal]]
  - [[#audio-and-sound][Audio and Sound]]
- [[#multimedia][Multimedia]]
  - [[#video][Video]]
    - [[#configuration][Configuration]]
    - [[#input][Input]]
  - [[#yt-dlp][yt-dlp]]
  - [[#aria2][aria2]]
- [[#web-browser][Web Browser]]
  - [[#containerized-wrapper][Containerized wrapper]]
  - [[#tridactyl][Tridactyl]]
- [[#emacs][Emacs]]
  - [[#basics][Basics]]
  - [[#early-initialization][Early Initialization]]
    - [[#packages-1][Packages]]
    - [[#special-key-remapping][Special Key Remapping]]
    - [[#fonts-1][Fonts]]
    - [[#some-configurations-that-might-make-sense-to-put-here][Some Configurations that might make sense to put here]]
  - [[#main-configurations][Main Configurations]]
    - [[#packages-2][Packages]]
    - [[#setupel][setup.el]]
    - [[#some-sane-configurations][Some Sane Configurations]]
      - [[#android-1][Android]]
    - [[#window-management][Window Management]]
    - [[#universal-argument][Universal Argument]]
    - [[#pcre][PCRE]]
    - [[#help][Help]]
    - [[#info][Info]]
    - [[#xdg][Xdg]]
    - [[#no-littering][No Littering]]
    - [[#modus-themes][Modus Themes]]
    - [[#mode-line][Mode Line]]
    - [[#midnight][Midnight]]
    - [[#auto-save][Auto Save]]
    - [[#recentf][Recentf]]
    - [[#save-history][Save History]]
    - [[#editorconfig][Editorconfig]]
    - [[#envrc][Envrc]]
    - [[#subword][Subword]]
    - [[#highlight-parentheses][Highlight Parentheses]]
    - [[#transient][Transient]]
    - [[#evil][Evil]]
      - [[#noun-verb-editing][Noun-Verb Editing]]
      - [[#move-up-and-down-a-list][Move up and down a list]]
      - [[#evil-surround][Evil Surround]]
      - [[#evil-replace-with-register][Evil Replace With Register]]
      - [[#evil-snipe][Evil Snipe]]
      - [[#evil-commentary][Evil Commentary]]
      - [[#window-map][Window map]]
    - [[#god-mode][God mode]]
    - [[#which-key][Which key]]
    - [[#posframe][Posframe]]
    - [[#eldoc][Eldoc]]
    - [[#ace-window][Ace Window]]
    - [[#spell-checking][Spell Checking]]
      - [[#flyspell-correct][Flyspell Correct]]
    - [[#xref][Xref]]
    - [[#topsy][Topsy]]
    - [[#re-builder][RE Builder]]
    - [[#orderless][Orderless]]
    - [[#vertico][Vertico]]
    - [[#marginalia][Marginalia]]
    - [[#consult][Consult]]
    - [[#embark][Embark]]
      - [[#consult-based-embark-cycle][Consult-based Embark Cycle]]
      - [[#embark-as-the-leader-key][Embark as the leader key]]
      - [[#open-in-chosen-window][Open in chosen window]]
      - [[#keybindings-for-copy][Keybindings for copy]]
      - [[#copy-file-name-with-line-number][Copy file name with line number]]
    - [[#tempel][Tempel]]
      - [[#eglot-tempel][Eglot-tempel]]
    - [[#corfu][Corfu]]
    - [[#visual-undo][Visual Undo]]
    - [[#hideshow][Hideshow]]
    - [[#pulse][Pulse]]
    - [[#electric-pair-mode][electric-pair-mode]]
    - [[#aggresive-indent][Aggresive Indent]]
    - [[#comint][Comint]]
    - [[#eshell][Eshell]]
      - [[#fish-completion][fish-completion]]
    - [[#ediff][Ediff]]
    - [[#magit][Magit]]
    - [[#project][Project]]
    - [[#emacsql][Emacsql]]
    - [[#epub][Epub]]
    - [[#pdf][Pdf]]
    - [[#org-mode][Org Mode]]
      - [[#general-settings][General Settings]]
      - [[#task-management][Task Management]]
      - [[#literate-programming][Literate Programming]]
      - [[#evil-org][Evil Org]]
      - [[#toc-org][Toc Org]]
      - [[#org-appear][Org Appear]]
      - [[#personal-knowledge-management][Personal Knowledge Management]]
      - [[#style-and-faces][Style and Faces]]
    - [[#english][English]]
      - [[#linting][Linting]]
      - [[#capitalizing][Capitalizing]]
      - [[#dictionary][Dictionary]]
    - [[#eglot][Eglot]]
    - [[#haskell][Haskell]]
    - [[#rust][Rust]]
    - [[#dhall][Dhall]]
    - [[#ron][Ron]]
    - [[#dart][Dart]]
    - [[#plantuml][PlantUML]]
    - [[#yaml][YAML]]
    - [[#vimrc][Vimrc]]
    - [[#go][Go]]
    - [[#email][Email]]
      - [[#mu4e][mu4e]]
    - [[#mpv][MPV]]
    - [[#pyim][PYIM]]
    - [[#vterm][vterm]]
    - [[#eat][Eat]]
    - [[#dired][Dired]]
      - [[#dired-rsync][dired-rsync]]
    - [[#emms][EMMS]]
    - [[#guix-2][Guix]]
    - [[#desktop-notification-daemon][Desktop Notification Daemon]]
- [[#references-and-recommendations][References and Recommendations]]

* Introduction
This is my all-in-one [[https://guix.gnu.org/][Guix]] configuration, working in progress. This aims to eventually replace and deprecate [[https://github.com/hiecaq/dotfiles][my dotfiles]], which has too many historical burdens.

Unless explicitly stated, all code in this configuration is under GPL3 license.

* System Configuration
This is the main entry point for =guix system=. It can be deployed with
#+begin_src sh
  sudo guix system -L build reconfigure build/system-configuration.scm
#+end_src

#+begin_src scheme :tangle "build/system-configuration.scm" :noweb yes
  (use-modules (gnu)
               (guix channels)
               (gnu system nss)
               (gnu packages haskell)
               (hiecaq services search)
               <<system-module>>
               )

  (use-service-modules desktop ssh xorg linux security-token sound)
  (use-package-modules bootloaders fonts games android)

  <<system-helper>>

  (define %channels
    (cons*
     <<guix-channel>>
     %default-channels))

  (operating-system
    <<operating-system>>

    (users (cons*
            <<operating-system-users>>
            %base-user-accounts))

    (packages (cons*
               <<system-packages>>
               %base-packages))

    (services (cons*
               <<system-services>>
               (modify-services %desktop-services
                 <<system-services-modify>>)))
    ;; Allow resolution of '.local' host names with mDNS.
    (name-service-switch %mdns-host-lookup-nss))
#+end_src

** Private Info
Host name shows up in some places, and I'm not good at naming so I just call it "desktop".
#+begin_src scheme :noweb-ref operating-system
  (host-name "desktop")
#+end_src

Time zone.  All Linuxes should be synchronized to the same UTC time, and local time is then displayed based on the time zone.
#+begin_src scheme :noweb-ref operating-system
  (timezone "Etc/UTC")
#+end_src

Nowadays locale should be just UTF-8.
#+begin_src scheme :noweb-ref operating-system
    (locale "en_US.utf8")
#+end_src

I use standard keyboard layout too.
#+begin_src scheme :noweb-ref operating-system
    (keyboard-layout (keyboard-layout "us"))
#+end_src

** Kernel, Firmware and Initial RAM Disk
I must confess that I have to use non-liberal firmware.
#+begin_src scheme :noweb-ref system-module
  (nongnu packages linux)
  (nongnu system linux-initrd)
#+end_src

Then the kernel and firmware are from nonguix channel:
#+begin_src scheme :noweb-ref operating-system
  (kernel linux)
  (initrd microcode-initrd)
  (firmware (list linux-firmware))
#+end_src

I use =xxhash= for btrfs checksum, so the corresponding modules to be added to the Initial Ram Disk modules.  See [[https://old.reddit.com/r/btrfs/comments/17ksj0w/installing_debian_with_xxhash/][here]].
#+begin_src scheme :noweb-ref operating-system
  (initrd-modules (append
                   (list "xxhash" "xxhash_generic")
                   %base-initrd-modules))
#+end_src

** Bootloader
use UEFI flavored GRUB.  Note that the mount point is =/efi= (instead of =/boot/efi=), as suggested by the [[https://wiki.archlinux.org/title/EFI_system_partition#Typical_mount_points][Arch Wiki]].
#+begin_src scheme :noweb-ref operating-system
  (bootloader (bootloader-configuration
               (bootloader grub-efi-bootloader)
               (targets '("/efi"))
               (keyboard-layout keyboard-layout)))
#+end_src

** File System
See [[https://www.hiecaq.org/posts/20241024T234951M098.html][my blog post]] for details on how I partitioned / formatted the file system.  This preparation cannot be done from Guix system declaration itself and has to be done manually (or with shell scripts).

firstly, we need to declare the mapped devices, which handles our LUKS-encrypted device.
#+begin_src scheme :noweb yes :noweb-ref operating-system
  (mapped-devices
   (list (mapped-device
          (source (uuid <<system-luks-device-uuid>>))
          (target "cryptbtrfs")
          (type luks-device-mapping))))
#+end_src

Then actual file systems are listed in this field:
#+begin_src scheme :noweb yes :noweb-ref operating-system
  (file-systems (append
                 (list
                  <<file-system>>
                  )
                 %base-file-systems))
#+end_src

*** BTRFS subvolumes
To begin with, since most things are on the encrypted btrfs partition, it is important to understand when to make subvolumes.  As far as I can tell, the main decision factor is if you want to back up the subvolume separately, or simply to exclude some subvolumes from the backups.

Thus, mostly everything under =/=, exclude =/home=, is managed by Guix, so seldom they need to be backed up.  The exceptions here I made are:
- =/home= :: as mentioned, I want it to be backed-up seperately
- =/swap= :: who need to back up swap?
- =/var/log= :: system logs, can be backed up often
- =/var/cache= and =/var/tmp= :: These are either temporary or can be regenerated, so no need to back up
#+begin_src scheme :noweb-ref file-system
  (%btrfs "@" "/" mapped-devices)
  (%btrfs "@home" "/home" mapped-devices)
  (%btrfs "@swap" "/swap" mapped-devices)
  (%btrfs "@log" "/var/log" mapped-devices)
  (%btrfs "@cache" "/var/cache" mapped-devices)
  (%btrfs "@tmp" "/var/tmp" mapped-devices)
#+end_src

Next, since I manage my home with guix home, most things do not need to be backed up either.  The exceptions are the "well known" user directories.
#+begin_src scheme :noweb-ref file-system
  (%btrfs "@documents" "/home/hiecaq/documents" mapped-devices)
  (%btrfs "@downloads" "/home/hiecaq/downloads" mapped-devices)
  (%btrfs "@videos" "/home/hiecaq/videos" mapped-devices)
  (%btrfs "@music" "/home/hiecaq/music" mapped-devices)
  (%btrfs "@pictures" "/home/hiecaq/pictures" mapped-devices)
#+end_src

The above ~%btrfs~ is defined as
#+begin_src scheme :noweb-ref system-helper
  (define* (%btrfs subvol mount-point dep #:key
                   (flags '(no-atime)))
    (file-system
     (device "/dev/mapper/cryptbtrfs")
     (mount-point mount-point)
     (type "btrfs")
     (flags flags)
     (options (string-append "compress=zstd,subvol=" subvol))
     (dependencies dep)))
#+end_src

Important things are:
- =no-atime=, which is good for btrfs' CoW
- =compress=zstd=, that is to enable btrfs' transparent compression with Zstandard algorithm.

*** TMP
Guix does not mount =/tmp= as =tmpfs= in ~%base-file-systems~ by default.  The reason is that Guix uses =/tmp= to build things, and the temporary build files can be too large to be contained in RAM, see [[https://logs.guix.gnu.org/guix/2024-10-27.log#080317][Rutherther's reply to me]].  However, my desktop's RAM is large enough, so
#+begin_src scheme :noweb-ref file-system
  (file-system
   (device "tmpfs")
   (mount-point "/tmp")
   (type "tmpfs")
   (flags '(no-suid no-dev))
   (options "size=80%")
   (check? #f))
#+end_src

*** EFI
The last thing is to mount the EFI system partition:
#+begin_src scheme :noweb yes :noweb-ref file-system
  (file-system
   (device (uuid <<system-efi-device-uuid>> 'fat))
   (mount-point "/efi")
   (type "vfat"))
#+end_src

*** Device IDs
This is what's displayed in =lsblk -f -o UUID /dev/nvme0n1p2=
#+name: system-luks-device-uuid
#+begin_src scheme :exports none
  "5e797e8b-d3b9-4693-b2f9-c17cf0943c34"
#+end_src

This is what's displayed in =lsblk -o UUID /dev/nvme0n1p1=
#+name: system-efi-device-uuid
#+begin_src scheme :exports none
  "B09A-E98C"
#+end_src

** Users
I only have one explicit user:
#+begin_src scheme :noweb-ref operating-system-users
  (user-account
   (name "hiecaq")
   (group "users")
   (supplementary-groups '("wheel" "netdev"
                           "input" "audio" "video"
                           "plocate" "adbusers")))
#+end_src

** Packages
:PROPERTIES:
:header-args:scheme: :noweb-ref system-packages
:END:
Currently just a list of fonts:
#+begin_src scheme
  font-hack
  font-google-noto
  font-google-noto-emoji
  font-google-noto-sans-cjk
#+end_src

** Services
:PROPERTIES:
:header-args:scheme: :noweb-ref system-services
:END:

*** Smart Card
#+begin_src scheme
  (service pcscd-service-type)
#+end_src

*** Game Controllers
We need the udev rules provided by Steam:
#+begin_src scheme
  (udev-rules-service 'steam steam-devices-udev-rules)
#+end_src

*** Android
To connect to Android devices, we need the following udev rule.  It requires the user to be in =adbusers= group to use =adb= / =fastboot= without root privilege.  We can automatically create the group here.
#+begin_src scheme
  (udev-rules-service 'android android-udev-rules
                      #:groups '("adbusers"))
#+end_src

*** Hardware monitor
To show the system fan speeds, my device need this kernel module:
#+begin_src scheme
  (service kernel-module-loader-service-type
           '("nct6683"))
#+end_src


** Default Services Modification
:PROPERTIES:
:header-args:scheme: :noweb-ref system-services-modify
:END:

*** Guix
We modify the system-wide channels (which will be used if a user does not have a channel list themselves) and add the substitute for Nonguix.
#+begin_src scheme
  (guix-service-type
   config => (guix-configuration
              (inherit config)
              (substitute-urls %substitute-urls)
              (channels %channels)
              (authorized-keys
               (append (list %nonguix-signing-key)
                       %default-authorized-guix-keys))))
#+end_src

#+begin_src scheme :noweb-ref system-helper
  (define %substitute-urls
    '("https://ci.guix.gnu.org"
      "https://substitutes.nonguix.org"))

  (define %nonguix-signing-key
    (plain-file "nonguix.pub" "\
  (public-key
   (ecc
    (curve Ed25519)
    (q #C1FD53E5D4CE971933EC50C9F307AE2171A2D3B52C804642A7A35F84F3A4EA98#)))"))
#+end_src

*** GDM
Somehow after log-in my mouse cursor disappears.  We need to add a configuration to =/etc/X11/xorg.conf.d/= to fix it, here is how to do that in Guix's way:
#+begin_src scheme
  (gdm-service-type
   config => (gdm-configuration
              (inherit config)
              (auto-suspend? #f)
              (xorg-configuration
               (let ((xorg-config ((@@(gnu services xorg) gdm-configuration-xorg) config)))
                 (xorg-configuration
                  (inherit xorg-config)
                  (extra-config (list %fix-amd-disappearing-cursor-conf)))))))
#+end_src

The fix is from https://forums.linuxmint.com/viewtopic.php?t=424779
#+begin_src scheme :noweb-ref system-helper
  (define %fix-amd-disappearing-cursor-conf "
  Section \"Device\"
    Identifier \"AMD\"
    Driver \"amdgpu\"
    Option \"SWCursor\" \"true\"
  EndSection
  ")
#+end_src

*** Audio
Remove pulseaudio.
#+begin_src scheme
  (delete pulseaudio-service-type)
  (alsa-service-type
   config => (alsa-configuration
              (inherit config)
              (pulseaudio? #f)))
#+end_src

* Home Configuration
This is the main entry point for =guix home=. It can be tested with
#+begin_src sh
  guix home -L build container build/home-configuration.scm
#+end_src
and deployed with
#+begin_src sh
  guix home -L build reconfigure build/home-configuration.scm
#+end_src

#+begin_src scheme :tangle "build/home-configuration.scm" :noweb yes
  (use-modules
   (gnu home)
   (gnu services)
   (gnu packages)
   <<home-module>>
   )

  (home-environment
   <<home-environment-conf>>
   (services
    (append
     <<home-environment-service>>
     )))
#+end_src

This is a list of packages that are not installed by services. Eventually this list should be empty.
#+begin_src scheme :noweb-ref home-environment-conf
  (packages (specifications->packages
             (list
              "neovim"
              "guile"
              )))
#+end_src

* Guix
This file defines those settings related to Guix itself.
#+begin_src scheme :tangle "build/hiecaq/home/guix.scm" :noweb yes
  (define-module (hiecaq home guix)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (gnu home services guix)
    #:use-module (gnu home services gnupg)
    #:use-module (gnu packages gnupg)
    #:use-module (guix gexp)
    #:use-module (guix channels))

  (define-public services
    (list
     <<guix-service>>
     ))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home guix) #:prefix guix:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  guix:services
#+end_src

** Locales
Set the locales as recommended in [[https://guix.gnu.org/manual/en/html_node/Application-Setup.html][the manual]].
#+begin_src scheme :noweb-ref guix-service
  (service
   (service-type
    (name 'home-locale)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "glibc-locales"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("GUIX_LOCPATH" . "${GUIX_PROFILE}/lib/locale"))))))
    (default-value #f)
    (description #f)))
#+end_src

** Channels
:PROPERTIES:
:header-args:scheme: :noweb-ref guix-channel
:END:

*** COMMENT Home Service
Since I'm using guix as a system, the home service is not needed.
#+begin_src scheme :noweb-ref guix-service
  (simple-service
   'variant-packages-service
   home-channels-service-type
   (list
    <<guix-channel>>
    ))
#+end_src

*** COMMENT RDE
[[https://git.sr.ht/~abcdw/rde][rde]] is a "developers and power user friendly GNU/Linux distribution based on GNU Guix package manager", which can be used as a channel directly. In this way, I can use the helper procedures that it defines.

I no longer need functionality belongs to rde, but I keep it here for future reference.
#+begin_src scheme
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
#+end_src

*** Nonguix
[[https://gitlab.com/nonguix/nonguix][nonguix]] holds non-free stuffs, including kernel, firmware, and other close-source binaries.
#+begin_src scheme
  (channel
   (name 'nonguix)
   (url "https://gitlab.com/nonguix/nonguix")
   (introduction
    (make-channel-introduction
     "897c1a470da759236cc11798f4e0a5f7d4d59fbc"
     (openpgp-fingerprint
      "2A39 3FFF 68F4 EF7A 3D29  12AF 6F51 20A0 22FB B2D5"))))
#+end_src

* Cross-Desktop Group (XDG)
This section defines those settings related to the [[https://www.freedesktop.org/wiki/Specifications/][XDG]] specifications.
#+begin_src scheme :tangle "build/hiecaq/home/xdg.scm" :noweb yes
  (define-module (hiecaq home xdg)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (gnu home services xdg)
    #:use-module (guix channels))

  (define-public services
    (list
     <<xdg-service>>
     ))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home xdg) #:prefix xdg:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  xdg:services
#+end_src

** Base Directories
See [[https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html][Enviroment Variables chapter in latest XDG Base Directory Specification]] for the description on their purposes.

Guix home [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/home.scm#n86][instantiate]] [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/home/services/xdg.scm#n148][it]] by default, so technically there is no configuration needed, unless we want to modify their values.

Note that their values are set in =$GUIX_HOME/setup-environment=, which should be run by =$HOME/.profile=, which is sourced at the beginning of a login shell.

** User Directories
As declared in [[https://www.freedesktop.org/wiki/Software/xdg-user-dirs/][xdg-user-dirs]], this defines "well known" user directories, and their localization.
#+begin_src scheme :noweb-ref xdg-service
  (simple-service
   'xdg-user-directories-config-service
   home-xdg-user-directories-service-type
   (home-xdg-user-directories-configuration
    (desktop     "$HOME/desktop")
    (documents   "$HOME/documents")
    (download    "$HOME/downloads")
    (music       "$HOME/music")
    (pictures    "$HOME/pictures")
    (publicshare "$HOME/public")
    (templates   "$HOME/templates")
    (videos      "$HOME/videos")))
#+end_src

* Shells
#+begin_src scheme :tangle "build/hiecaq/home/shell.scm"
  (define-module (hiecaq home shell)
    #:use-module (gnu home)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (guix channels)
    #:use-module (gnu home services guix)
    #:use-module (gnu home services shells)
    #:use-module (guix gexp))
#+end_src

TODO: I should split this out later.
#+begin_src scheme :tangle "build/hiecaq/home/shell.scm" :noweb yes
  (define-public services
    (list
     (simple-service
      'extend-environment-variables
      home-environment-variables-service-type
      `(("PS1" . "$ ")
        ("MANPAGER" . "nvim +Man!")
        ("MANWIDTH" . "80")
        ("QT_AUTO_SCREEN_SCALE_FACTOR" . "1")
        ("RUSTUP_UPDATE_ROOT" . "https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup")
        ("RUSTUP_DIST_SERVER" . "https://mirrors.tuna.tsinghua.edu.cn/rustup")))
     <<shell-service>>
     ))
#+end_src

Add this module and its services:
#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home shell) #:prefix shell:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  shell:services
#+end_src
** Fish
:PROPERTIES:
:header-args:scheme: :noweb-ref shell-service
:END:
I use [[https://fishshell.com/][fish]] as a backup interactive-use-only shell.
#+begin_src scheme
  (service
   home-fish-service-type)
#+end_src

** COMMENT Zsh
:PROPERTIES:
:header-args:scheme: :noweb-ref shell-service
:END:
I'm currently using [[https://www.zsh.org/][zsh]] as my primary shell.
#+begin_src scheme
  (service
   home-zsh-service-type
   (home-zsh-configuration
    (zshrc
     (list (slurp-file-like (local-file "../../.zshrc"
                                        "zshrc"))
           (slurp-file-like (local-file "../../.aliases"
                                        "aliases"))))))
#+end_src

*** syntax highlighting
Add [[https://github.com/zsh-users/zsh-syntax-highlighting][zsh-syntax-highlighting]], which provides "fish shell like syntax highlighting for Zsh."
#+begin_src scheme
  (service
   (service-type
    (name 'home-zsh-syntax-highlighting)
    (extensions
     (list
      (service-extension home-zsh-plugin-manager-service-type
                         (const
                          (list
                           (specification->package
                            "zsh-syntax-highlighting"))))
      (service-extension
       home-zsh-service-type
       (const
        (home-zsh-extension
         (zshrc '("# Improve highlighting")))))))
    (default-value #f)
    (description #f)))
#+end_src
And its configuration
#+begin_src sh :tangle "build/.zshrc"
  # Declare the variable
  typeset -A ZSH_HIGHLIGHT_STYLES

  # disable highlighting for unknown-token
  ZSH_HIGHLIGHT_STYLES[unknown-token]='none'

  # use blue to highlight command(e.g., git)
  ZSH_HIGHLIGHT_STYLES[command]='fg=004'

  # builtins(e.g., pwd): blue, italic
  ZSH_HIGHLIGHT_STYLES[builtin]='fg=004,standout'

  # commandseparator(;, &&): lighter gray
  ZSH_HIGHLIGHT_STYLES[commandseparator]='fg=014'

  # alias: blue
  ZSH_HIGHLIGHT_STYLES[alias]='fg=004'

  # single hyphen-option: darker red,italic
  ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=001'

  # double hyphen-option: darker red
  ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=001'

  # quoted arguments(strings)
  ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=006'
  ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=006'

  # dollar quoted arguments:gold
  ZSH_HIGHLIGHT_STYLES[dollar-quoted-argument]='fg=003'

  # other commands: red
  ZSH_HIGHLIGHT_STYLES[arg0]='fg=001'

  # To define styles for nested brackets up to level 4
  ZSH_HIGHLIGHT_STYLES[bracket-level-1]='fg=010'
  ZSH_HIGHLIGHT_STYLES[bracket-level-2]='fg=014'
  ZSH_HIGHLIGHT_STYLES[bracket-level-3]='fg=010'
  ZSH_HIGHLIGHT_STYLES[bracket-level-4]='fg=014'
  ZSH_HIGHLIGHT_STYLES[bracket-error]='fg=001'
  ZSH_HIGHLIGHT_STYLES[cursor-matchingbracket]='fg=007'

  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
#+end_src

** Tools
:PROPERTIES:
:header-args:scheme: :noweb-ref shell-service
:END:
There are many tools that enhance the command line user experience.
*** Certificates
See the [[https://guix.gnu.org/manual/en/html_node/X_002e509-Certificates.html][Guix documentation]] for details on the CA settings. TODO: Maybe this should be in a higher-level heading?
#+begin_src scheme
  (service
   (service-type
    (name 'home-certs)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "nss-certs"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("SSL_CERT_DIR" . "$HOME/.guix-home/profile/etc/ssl/certs")
                ("SSL_CERT_FILE" . "$SSL_CERT_DIR/ca-certificates.crt")
                ("GIT_SSL_CAINFO" . "$SSL_CERT_FILE")
                ("CURL_CA_BUNDLE" . "$SSL_CERT_FILE"))))))
    (default-value #f)
    (description #f)))
#+end_src

*** bat
Add [[https://github.com/sharkdp/bat][bat]], which is a =cat= clone with colors.
#+begin_src scheme
  (service
   (service-type
    (name 'home-bat)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "bat"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("BAT_THEME" . "TwoDark"))))))
    (default-value #f)
    (description #f)))
#+end_src

*** eza
[[https://github.com/eza-community/eza][eza]] is a community-revived fork of [[https://github.com/ogham/exa][exa]], which is "a modern replacement for =ls=".
#+begin_src scheme
  (service
   (service-type
    (name 'home-eza)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "eza"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("EZA_COLORS" .
                 "*.zip=0:*.gz=0:*.rar=0:*.tar=0:*.7z=0:ex=31:di=244;1"))))))
    (default-value #f)
    (description #f)))
#+end_src

*** ripgrep
Add [[https://github.com/BurntSushi/ripgrep][ripgrep]], which is "a line-oriented search tool that recursively searches the current directory for a regex pattern". In other words, it is a modern =grep=.
#+begin_src scheme
  (simple-service
   'home-ripgrep
   home-profile-service-type
   (list
    (specification->package
     "ripgrep")))
#+end_src

*** fd
Add [[https://github.com/sharkdp/fd][fd]], which is "a simple, fast and user-friendly alternative to 'find'".
#+begin_src scheme
  (simple-service
   'home-fd
   home-profile-service-type
   (list
    (specification->package
     "fd")))
#+end_src

*** Direnv
[[https://direnv.net/][direnv]] is the environment switcher on the shell level, based on current directories.
#+begin_src scheme
  (simple-service
   'home-direnv
   home-profile-service-type
   (list
    (specification->package
     "direnv")))
#+end_src

** Aliases
And the aliases that I'm using:
#+begin_src sh :tangle "build/.aliases"
  alias v="nvim"
  alias e="emacsclient -c --no-wait"
  alias g="git"
  alias ls="exa"
  alias l="exa --git-ignore"
  alias l.="ls -lah"
  alias gc="git commit -v"
#+end_src

* Fonts
:PROPERTIES:
:header-args:scheme: :tangle "build/hiecaq/home/fonts.scm"
:END:

This file describe how fonts are configured.
#+begin_src scheme
  (define-module (hiecaq home fonts)
    #:use-module (gnu services)
    #:use-module (gnu home services)
    #:use-module (gnu packages fonts)
    #:use-module (gnu packages fontutils)
    #:use-module (guix gexp)
    #:use-module ((gnu home services fontutils) #:prefix fontutils:))
#+end_src

The ~home-fontconfig-service-type~ from vanilla =guix= comes with a =fonts.conf= that is literately inconfigurable, so we have to overwrite it.
SIDE NOTES: I cannot use ~@@~ to import ~regenerate-font-cache-gexp~ from =(gnu home services fontutils)= I have totally no idea why.
#+begin_src scheme
  (define (add-fontconfig-config-file he-symlink-path)
    `(("fontconfig/fonts.conf"
       ,(local-file "../../fonts.conf"))))

  (define (regenerate-font-cache-gexp _)
    `(("profile/share/fonts"
       ,#~(system* #$(file-append fontconfig "/bin/fc-cache") "-fv"))))

  (define home-fontconfig-service-type
    (service-type (name 'home-fontconfig)
                  (extensions
                   (list (service-extension
                          home-xdg-configuration-files-service-type
                          add-fontconfig-config-file)
                         (service-extension
                          home-run-on-change-service-type
                          regenerate-font-cache-gexp)
                         (service-extension
                          home-profile-service-type
                          (const (list fontconfig)))))
                  (default-value #f)
                  (description
                   "Provides configuration file for fontconfig and make
  fc-* utilities aware of font packages installed in Guix Home's profile.")))

  (define-public (modify-essential-service services)
    `(,@(modify-services
         services
         (delete fontutils:home-fontconfig-service-type))
      ,(service home-fontconfig-service-type)))
#+end_src

Here is the modified =fonts.conf=:
#+begin_src nxml :tangle "build/fonts.conf" :comments no
  <?xml version="1.0"?>
  <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
  <fontconfig>
      <dir>~/.guix-home/profile/share/fonts</dir>
      <alias>
          <family>serif</family>
          <prefer>
              <family>Noto Serif</family>
              <family>Noto Serif CJK SC</family>
              <family>Noto Serif CJK JP</family>
              <family>Noto Serif CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>sans-serif</family>
          <prefer>
              <family>Noto Sans</family>
              <family>Noto Sans CJK SC</family>
              <family>Noto Sans CJK JP</family>
              <family>Noto Sans CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>monospace</family>
          <prefer>
              <family>Noto Sans Mono</family>
              <family>Noto Sans Mono CJK SC</family>
              <family>Noto Sans Mono CJK JP</family>
              <family>Noto Sans Mono CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>emoji</family>
          <prefer>
              <family>Noto Color Emoji</family>
          </prefer>
      </alias>
  </fontconfig>
#+end_src

this module simply provides a single service that install the fonts needed.
#+begin_src scheme
  (define-public services
    (list (simple-service
           'extend-environment-variables
           home-profile-service-type
           (list
            font-hack
            font-google-noto
            font-google-noto-sans-cjk))))
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home fonts) #:prefix fonts:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  fonts:services
#+end_src

* Search
#+begin_src scheme :tangle "build/hiecaq/services/search.scm" :noweb yes
  (define-module (hiecaq services search)
    #:use-module (guix gexp)
    #:use-module (guix packages)
    #:use-module (gnu services)
    #:use-module (gnu services configuration)
    #:use-module (gnu packages search)
    #:use-module (gnu system shadow) ;; account-service-type
    #:use-module (ice-9 match)
    #:use-module (ice-9 string-fun)
    #:use-module (srfi srfi-1)
    #:use-module (srfi srfi-26)
    #:export (locate-configuration
              locate-configuration?
              locate-configuration-locate
              locate-configuration-fields
              locate-service-type))

  (define (uglify-field-name field-name)
    (let* ((str (symbol->string field-name))
           (up (string-upcase str)))
      (if (string-suffix? "?" up)
          (string-replace-substring (string-drop-right up 1) "-" "_")
          (string-replace-substring up "-" ""))))

  (define (strings? lst)
    (every string? lst))

  (define (serialize-field field-name value)
    #~(string-append #$(uglify-field-name field-name)
                     " = \""
                     #$value
                     "\"\n"))

  (define (serialize-strings field-name strs)
    (serialize-field field-name (string-join strs " ")))

  (define (serialize-boolean field-name value)
    (serialize-field field-name (if value "yes" "no")))

  (define serialize-group empty-serializer)
  (define (group? s) (string? s))

  (define-maybe strings)
  (define-maybe boolean)
  (define-maybe group)

  (define-configuration locate-configuration
    (locate
     (package plocate)
     "The locate package to use.")
    (group
     (group "locate")
     "Locate group used to run updatedb.")
    (prune-fs
     maybe-strings
     "List of file system types (as used in /etc/mtab) which should not be scanned.")
    (prune-names
     maybe-strings
     "List of directory names (without paths) which should not be scanned.")
    (prune-paths
     maybe-strings
     "List of directory absolute paths which should not be scanned.")
    (prune-bind-mounts?
     maybe-boolean
     "If true, bind mounts are not scanned."))

  (define (locate-etc config)
    `(("updatedb.conf" ,(mixed-text-file
                         "updatedb.conf"
                         "# Generated by 'locate-service'.\n"
                         (serialize-configuration
                          config locate-configuration-fields)))))

  (define (locate-group config)
    (list
     (user-group
      (name (locate-configuration-group config))
      (system? #t))))

  (define locate-service-type
    (service-type
     (name 'locate)
     (extensions
      (list (service-extension profile-service-type (compose list locate-configuration-locate))
            (service-extension etc-service-type locate-etc)
            (service-extension account-service-type locate-group)))
     (default-value (locate-configuration))
     (description #f)))
#+end_src

** System service
This is translated from [[https://gitlab.archlinux.org/archlinux/packaging/packages/plocate/-/blob/main/updatedb.conf][Arch's configuration]]
#+begin_src scheme :noweb-ref system-services
  (service locate-service-type
           (locate-configuration
            (group "plocate")
            (prune-fs '("9p" "afs" "anon_inodefs"
                        "auto" "autofs" "bdev" "binfmt_misc" "cgroup" "cifs" "coda" "configfs"
                        "cpuset" "cramfs" "debugfs" "devpts" "devtmpfs" "ecryptfs" "exofs"
                        "ftpfs" "fuse" "fuse.encfs" "fuse.s3fs" "fuse.sshfs" "fusectl" "gfs"
                        "gfs2" "hugetlbfs" "inotifyfs" "iso9660" "jffs2" "lustre" "mqueue"
                        "ncpfs" "nfs" "nfs4" "nfsd" "pipefs" "proc" "ramfs" "rootfs"
                        "rpc_pipefs" "securityfs" "selinuxfs" "sfs" "shfs" "smbfs" "sockfs"
                        "sshfs" "sysfs" "tmpfs" "ubifs" "udf" "usbfs" "vboxsf"))
            (prune-names '(".git" ".hg" ".svn" ".cache"))
            (prune-paths '("/afs" "/media" "/mnt"
                           "/net" "/sfs" "/tmp" "/udev" "/gnu/store"
                           "/var/cache" "/var/lock" "/var/run" "/var/tmp"))))
#+end_src
* Desktop Environment
My "desktop environment" is plain window management with friends.

#+begin_src scheme :tangle "build/hiecaq/home/de.scm" :noweb yes
  (define-module (hiecaq home de)
    #:use-module (guix gexp)
    #:use-module (gnu services)
    #:use-module (gnu home services)
    <<de-use-module>>)

  (define-public services
    (list
     <<de-service>>))
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home de) #:prefix de:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  de:services
#+end_src

** Display
I currently use Guix's default display manager, i.e. =gdm=, and when there is no =*.desktop= of WMs available in its search path, it can log in with the user provided =~/.xsession= executable (which won't be displayed in the selection menu).

So, simply
#+begin_src sh :tangle "build/xsession" :shebang #!/usr/bin/env bash
  exec xmonad
#+end_src

#+begin_src scheme :noweb-ref de-use-module
  #:use-module (gnu packages wm)
#+end_src

#+begin_src scheme :noweb-ref de-service
  (service
   (service-type
    (name 'home-wm)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               xmonad
               ghc-xmonad-contrib
               xmobar)))
      (service-extension
       home-files-service-type
       ;; recursive to keep x bits, see https://lists.gnu.org/archive/html/help-guix/2023-03/msg00190.html
       (const `((".xsession" ,(local-file "../../xsession" #:recursive? #t)))))
      (service-extension
       home-xdg-configuration-files-service-type
       (const `(("xmobar/xmobar.hs" ,(local-file "../../xmobar.hs"))
                )))))
    (default-value #f)
    (description #f)))
#+end_src

** Status Bar
:PROPERTIES:
:header-args:haskell: :tangle "build/xmobar.hs"
:END:
I use [[https://codeberg.org/xmobar/xmobar][xmobar]] as the status bar.

#+begin_src haskell
  {-# LANGUAGE OverloadedStrings #-}

  import Xmobar
  import Xmobar.Plugins.Monitors.Common hiding (template)
#+end_src

First define the absolute path to devices and drivers in the sysfs:
#+begin_src haskell
  nct6683Dir :: String
  nct6683Dir = "/sys/devices/platform/nct6683.2592/"

  amdgpuDir :: String
  amdgpuDir = "/sys/bus/pci/drivers/amdgpu/"
#+end_src

Definitions for monitors, see the subheadings.
#+begin_src haskell :noweb yes
  <<xmobar-monitor-funcs>>

  data MyMonitor = Invalid
    | <<xmobar-monitor-ctor>>
    deriving (Show,Read,Eq)

  instance Exec MyMonitor where
    <<xmobar-monitor-alias>>

    <<xmobar-monitor-run>>
#+end_src

Then, the main configuration:
#+begin_src haskell
  sepToRight :: String
  sepToRight = "\57521"

  sepToLeft :: String
  sepToLeft = "\57523"

  config :: Config
  config = defaultConfig
    {
   font = "xft:DejavuSansM Nerd Font:size=8:bold:antialias=true,Noto Sans CJK SC:size=8:antialias=true"
         , bgColor = "black"
         , fgColor = "#ebdbb2"
         , alpha = 98
         , position = TopW C 100
         , commands = [ Run XMonadLog
                      , Run $ Cpu ["-L","15","-H","50", "-w", "2", "-c", "0",
                                   "--normal","#fabd2f","--high","#cc241d",
                                   "-t", "<total>%"] 10
                      , Run $ K10Temp "0000:00:18.3" ["-t", "<Tdie>C|<Tccd1>C",
                                                      "-L", "40", "-H", "60",
                                                      "--normal","#fabd2f","--high","#cc241d"] 50

                      , Run $ Fan "cpufan" nct6683Dir "fan1_input" [] 50
                      , Run $ Fan "pumpfan" nct6683Dir "fan2_input" [] 50
                      , Run $ Fan "sysfan" nct6683Dir "fan3_input" [] 50
                      , Run $ Fan "gpufan" (amdgpuDir ++ "0000:03:00.0/") "fan1_input" [] 50

                      , Run $ AmdgpuTemp "0000:03:00.0" ["-t", "<edge>C|<junction>C|<mem>C",
                                                        "-L", "60", "-H", "80",
                                                        "--normal","#fabd2f","--high","#cc241d"] 50

                      , Run $ Memory ["-c", "0", "-w", "2", "-t","<usedratio>%"] 10
                      , Run $ Date "%a %Y-%m-%d <fc=#8be9fd>%H:%M</fc>" "date" 10
                      , Run $ DiskU [("/", "<free>/<size>")]
                                  ["-L", "10", "-H", "30", "-m", "1", "-p", "3", "--normal","#fabd2f","--low","#cc241d"]
                                  18000
                      , Run $ Network "enp16s0" ["-L","10000","-H","100000",
                                                 "--align", "l",
                                            "-S", "true",
                                            "--normal","#fabd2f","--high","#cc241d",
                                                "-t", "D<rx>/U<tx>"] 10
                      ]
         , sepChar = "%"
         , alignSep = "}{"
         , template = unwords
           ["%XMonadLog%"
           , sepToRight
           , "}{"
           , sepToLeft , "%enp16s0%"
           , sepToLeft , "%disku%"
           , sepToLeft , "%cpu%"
           , sepToLeft , "%k10temp%", "[%cpufan% %sysfan% %pumpfan%]"
           , sepToLeft , "%memory%"
           , sepToLeft , "%amdgputemp%", "[%gpufan%]"
           , sepToLeft , "%date%"]
    }

  main :: IO ()
  main = configFromArgs config >>= xmobar
#+end_src

*** AmdGPU temperature monitor
#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-funcs
  amdgpuTempConfig :: IO MConfig
  amdgpuTempConfig = mkMConfig
         "Temp: <mem>C" -- template
         ["edge", "junction", "mem"
         ] -- available replacements

  runAmdgpuTemp :: [String] -> Monitor String
  runAmdgpuTemp args = do
     dn <- getConfigValue decDigits
     failureMessage <- getConfigValue naString
     let slot = head args
         path = [amdgpuDir ++ slot ++ "/hwmon/hwmon", "/temp", "_input"]
         divisor = 1e3 :: Double
         show' = showDigits (max 0 dn)
     checkedDataRetrieval failureMessage [path] Nothing (/divisor) show'

#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-ctor
  AmdgpuTemp Slot Args Rate
#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-alias
  alias (AmdgpuTemp _ _ _) = "amdgputemp"
#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-run
  start (AmdgpuTemp s a r) = runM (a ++ [s]) amdgpuTempConfig runAmdgpuTemp r
#+end_src

*** Fan speed monitor
Actually this monitor works for any numbered input; but currently I just use it for reading fan speeds.
#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-funcs
  fanConfig :: IO MConfig
  fanConfig =
    mkMConfig "<fan>" ["fan"]

  runFan :: FilePath -> String -> [String] -> Monitor String
  runFan p s _ =
    let paths = [p ++ "hwmon/hwmon", "/" ++ s]
        failureMessage = "Cannot read: " ++ show paths
        fmt x = show (truncate x :: Int)
    in checkedDataRetrieval failureMessage [paths] Nothing id fmt
#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-ctor
  Fan String FilePath String Args Rate
#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-alias
  alias (Fan s _ _ _ _) = s
#+end_src

#+begin_src haskell :tangle no :noweb-ref xmobar-monitor-run
  start (Fan _ p s a r) = runM a fanConfig (runFan p s) r
#+end_src

** D-Bus
Start a session-specific D-Bus for unprivileged apps:
#+begin_src scheme :noweb-ref de-use-module
  #:use-module (gnu home services desktop)
#+end_src

#+begin_src scheme :noweb-ref de-service
  (service home-dbus-service-type)
#+end_src

** XDG Desktop Portal
[[https://flatpak.github.io/xdg-desktop-portal/][xdg-desktop-portal]] exposes a series of D-bus interface to give sandboxed application access to some host system functionalities, most notably file-picker, in a way similar to Android nowadays.

There are several daemons involved, and all of them will be automatically started the first time related D-bus events happen:
- =xdg-desktop-portal=, the daemon [[https://flatpak.github.io/xdg-desktop-portal/docs/terminology.html#][provides the API that application interacts with]].
- =xdg-document-portal=, the daemon that [[https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.Documents.html][binds the shared files inside and outside sandboxes]], i.e under =/run/usr/$UID/doc=
- =xdg-permission-store=, the daemon that [[https://github.com/flatpak/xdg-desktop-portal/wiki/The-Permission-Store/][keeps the permissions which a user has given to apps]].
- =xdg-desktop-portal-gtk=, the daemon that is the back-end that actually handles the translated and standardized requests.
BTW, if the portal does not work immediately after reconfigure, try reboot the system.

#+begin_src scheme :noweb-ref de-use-module
  #:use-module (gnu packages freedesktop)
#+end_src

#+begin_src scheme :noweb-ref de-service
  (service
   (service-type
    (name 'home-xdg-desktop-portal)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list xdg-desktop-portal
                    xdg-desktop-portal-gtk)))
      (service-extension
       home-xdg-configuration-files-service-type
       (const `(("xdg-desktop-portal/portals.conf" ,(local-file "../../portals.conf")))))))
    (default-value #f)
    (description #f)))
#+end_src

The following file set using =xdg-desktop-portal-gtk= as the default backend. There can actually be multiple backends running at the same time.
#+begin_src conf :tangle "build/portals.conf"
  [preferred]
  default=gtk
#+end_src

** Audio and Sound
I use a user [[https://gitlab.freedesktop.org/pipewire/pipewire][pipewire]] session.
#+begin_src scheme :noweb-ref de-use-module
  #:use-module (gnu home services sound)
#+end_src

#+begin_src scheme :noweb-ref de-service
  (service home-pipewire-service-type)
#+end_src

* Multimedia
#+begin_src scheme :tangle "build/hiecaq/home/multimedia.scm" :noweb yes
  (define-module (hiecaq home multimedia)
    #:use-module (guix gexp)
    #:use-module (gnu services)
    #:use-module (gnu home services)
    #:use-module (gnu home services xdg)
    <<multimedia-use-module>>)

  (define-public services
    (list
     <<multimedia-service>>))
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home multimedia) #:prefix multimedia:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  multimedia:services
#+end_src

** Video
I use mpv.
#+begin_src scheme :noweb-ref multimedia-use-module
  #:use-module (gnu packages video)
#+end_src

#+begin_src scheme :noweb-ref multimedia-service
  (service
   (service-type
    (name 'home-mpv)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list mpv)))
      (service-extension
       home-xdg-configuration-files-service-type
       (const `(("mpv/mpv.conf" ,(local-file "../../mpv.conf"))
                ("mpv/input.conf" ,(local-file "../../mpv-input.conf"))
                ("mpv/script-opts/ytdl_hook.conf" ,(local-file "../../mpv-ytdl.conf"))
                ("yt-dlp/config" ,(local-file "../../yt-dlp.conf")))))
      (service-extension
       home-xdg-mime-applications-service-type
       (const (home-xdg-mime-applications-configuration
               (default '((video/webm . mpv.desktop))))))))
    (default-value #f)
    (description #f)))
#+end_src

*** Configuration
:PROPERTIES:
:header-args:conf: :tangle "build/mpv.conf"
:END:

Preferred languages for audio and subtitles.
#+begin_src conf
  alang=jp,jpn,Japanese,en
  slang=chs,cht,ch,jp,jpn,en,eng,sc,tc
  sub-auto=fuzzy
#+end_src

Screenshots.
#+begin_src conf
  screenshot-format=png
  screenshot-template="%F/%wH_%wM_%wS_%wT"
  screenshot-directory=~/pictures/videoclip/
#+end_src

Only display error or worse for input.
#+begin_src conf
  msg-level=input=error
#+end_src

Disable window borders.
#+begin_src conf
  no-border
#+end_src

recommended settings from [[https://vcb-s.com/archives/7594][VCB-Studio]]:
#+begin_src conf
  profile=high-quality
  cscale=catmull_rom

  deband=yes

  icc-profile-auto=yes
  blend-subtitles=video

  video-sync=display-resample
  interpolation=yes
  tscale=oversample
#+end_src

*** Input
:PROPERTIES:
:header-args:conf: :tangle "build/mpv-input.conf"
:END:

First, disable default bindings.
#+begin_src conf :tangle "build/mpv.conf"
  no-input-default-bindings
#+end_src

Use vim-like keybindings for seek (in seconds):
#+begin_src conf
  l seek   5
  h seek  -5
  L seek  60
  H seek -60
#+end_src

Use vim-like keybindings for volume adjustment (in percentage):
#+begin_src conf
  j add volume -2
  k add volume 2

  J add volume -10
  K add volume 10
#+end_src

Toggle mute state.
#+begin_src conf
  m cycle mute
  M set mute yes
#+end_src

Use both =RET= and =SPC= for toggling pause and play.
#+begin_src conf
  SPACE cycle pause
  ENTER cycle pause
#+end_src

Toggle full screen.
#+begin_src conf
  f cycle fullscreen
#+end_src

Toggle always-on-top.
#+begin_src conf
  T cycle ontop
#+end_src

Quit.  =quit-watch-later= saves watch state to =$XDG_STATE_HOME/mpv/watch_later=.
#+begin_src conf
  q quit
  Q quit-watch-later
#+end_src

Adjust play speed
#+begin_src conf
  = set speed 1.0 # reset
  ) multiply speed 1.1
  ( multiply speed 0.9
#+end_src

Skip to chapters
#+begin_src conf
  ] add chapter 1
  [ add chapter -1
#+end_src

Skip to next or previous subtitle
#+begin_src conf
  { no-osd sub-seek -1
  } no-osd sub-seek 1
#+end_src

Skip to next or previous files.
#+begin_src conf
  N playlist-next
  P playlist-prev
#+end_src

Adjust subtitle delay
#+begin_src conf
  Ctrl+[ add sub-delay       -0.1
  Ctrl+] add sub-delay       +0.1
  Ctrl+{ secondary-sub-delay -0.1
  Ctrl+} secondary-sub-delay +0.1
#+end_src

Adjust audio delay, to fix audio/video out-of-sync
#+begin_src conf
  ctrl++ add audio-delay 0.100
  ctrl+- add audio-delay -0.100
#+end_src

Take screenshot with or without subtitle
#+begin_src conf
  s async screenshot                     # take a screenshot
  S async screenshot video # ...without subtitles
#+end_src

Cycle subtitles.
#+begin_src conf
  n cycle sub      # cycle through subtitles
  p cycle sub down # ...backwards
#+end_src

Toggle whether disabling ASS style in the subtitle file.
#+begin_src conf
  U cycle-values sub-ass-style-override "force" "no"
#+end_src

Cycle audio.
#+begin_src conf
  @ cycle audio
  ^ cycle audio down
#+end_src

Show information on the playback.
#+begin_src conf
  I script-binding stats/display-stats-toggle
#+end_src

** yt-dlp
#+begin_src conf :tangle "build/mpv-ytdl.conf"
  try_ytdl_first=yes
#+end_src

#+begin_src conf :tangle "build/yt-dlp.conf"
  -o ~/videos/%(title)s.%(ext)s

  # external downloader
  --external-downloader aria2c
  --external-downloader-args '-c -j 3 -x 3 -s 3 -k 1M'

#+end_src

** aria2
#+begin_src scheme :noweb-ref multimedia-use-module
  #:use-module (gnu packages bittorrent)
#+end_src

#+begin_src scheme :noweb-ref multimedia-service
  (service
   (service-type
    (name 'home-aria2)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list aria2)))
      (service-extension
       home-xdg-configuration-files-service-type
       (const `(("aria2/aria2.conf" ,(local-file "../../aria2.conf")))))))
    (default-value #f)
    (description #f)))
#+end_src

* Web Browser
#+begin_src scheme :tangle "build/hiecaq/home/browser.scm" :noweb yes
  (define-module (hiecaq home browser)
    #:use-module (guix gexp)
    #:use-module (gnu services)
    #:use-module (gnu home services)
    #:use-module (gnu home services xdg)
    <<browser-use-module>>)

  (define-public services
    (list
     <<browser-service>>))
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home browser) #:prefix browser:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  browser:services
#+end_src

** Containerized wrapper
I use Firefox.

For security and privacy reasons, I wrap it in a script that invokes =guix shell --container=.

This script is based on =nonguix/multiarch-container.scm=, just simplified.
#+begin_src scheme :tangle "build/hiecaq/packages/browser.scm" :noweb yes
  (define-module (hiecaq packages browser)
    #:use-module (guix)
    #:use-module (gnu packages)
    #:use-module (gnu packages base)
    #:use-module (guix build-system)
    #:use-module (guix build-system trivial)
    #:use-module ((guix licenses) #:prefix license:))

  (define-public firefox-containered
    (let ((wrapper (program-file
                    "firefox"
                    (with-imported-modules '((guix build utils))
                      #~(begin
                          (use-modules (guix build utils))
                          (let* ((xdg-data-home (getenv "XDG_DATA_HOME"))
                                 (xdg-runtime (getenv "XDG_RUNTIME_DIR"))
                                 (home (getenv "HOME"))
                                 (DEBUG (equal? (getenv "DEBUG") "1"))
                                 (args (cdr (command-line)))
                                 (command (if DEBUG '()
                                              `("--" "firefox" ,@args))))
                            (format #t "\n* Launching ~a in container.\n\n"
                                    "firefox")
                            (when DEBUG
                              (format #t "* DEBUG set to 1: Starting shell. Launch application manually with: ~a.\n\n"
                                      "firefox"))
                            (apply invoke
                                   `("guix" "shell"
                                     "--container" "--no-cwd" "--network"
                                     "--share=/dev/snd/seq"
                                     "--preserve=^DISPLAY$"
                                     "--preserve=^XAUTHORITY$"
                                     "--preserve=^DBUS_"
                                     "--preserve=XDG_RUNTIME_DIR"
                                     ,(string-append "--expose=" (getenv "XAUTHORITY"))
                                     "--expose=/sys/class/input"
                                     "--expose=/sys/devices"
                                     "--expose=/sys/dev"
                                     "--expose=/sys/bus/pci"
                                     ,(string-append "--expose=" xdg-runtime "/pulse")
                                     "--expose=/dev/dri"
                                     "--expose=/run/user/1000/bus"
                                     ,(string-append "--share=" home "/.mozilla")
                                     ,(string-append "--share=" home "/downloads" "=" home "/Downloads")
                                     "firefox"
                                     "coreutils"
                                     "which"
                                     "font-adobe-source-han-sans"
                                     "fontconfig"
                                     "dbus"
                                     ,@command))))))))
      (package
        (name "firefox-containered")
        (version "0.0.1")
        (source #f)
        (inputs `(("wrapper" ,wrapper)))
        (native-inputs (list (@(nongnu packages mozilla) firefox)))
        (build-system trivial-build-system)
        (arguments
         (list
          #:modules '((guix build utils))
          #:builder
          '(begin
             (use-modules (guix build utils))
             (let* ((out (assoc-ref %outputs "out"))
                    (wrapper-target (assoc-ref %build-inputs "wrapper"))
                    (wrapper-dest (string-append out "/bin/" "firefox"))
                    (desktop-file-target (string-append (assoc-ref %build-inputs "firefox")
                                                        "/share/applications/firefox.desktop"))
                    (desktop-file-destdir (string-append out "/share/applications/")))
               (mkdir-p (string-append out "/bin"))
               (symlink wrapper-target wrapper-dest)
               (install-file desktop-file-target desktop-file-destdir)
               (substitute* (string-append desktop-file-destdir "firefox.desktop")
                 (("^Exec=.+/firefox") (string-append "Exec=" out "/bin/firefox"))
                 (("^(GenericName|Name|Comment|Keywords)\\[.+\\].+$") "")
                 (("^Icon.+$") ""))))))
        (home-page "https://www.hiecaq.org")
        (synopsis "Containerized wrapper for Firefox")
        (description "Containerized wrapper for Firefox.")
        (license license:gpl3+))))
#+end_src


#+begin_src scheme :noweb-ref browser-use-module
  #:use-module (hiecaq packages browser)
#+end_src

#+begin_src scheme :noweb-ref browser-service
  (simple-service
   'home-firefox
   home-profile-service-type
   (list
    firefox-containered))
#+end_src

** Tridactyl
[[https://github.com/tridactyl/tridactyl][tridactyl]] is the WebExtension successor of [[https://vimperator.org/][Vimperator]] and [[https://github.com/5digits/dactyl][Pentadactyl]].

It can have talk to a native messenger running locally, so that it can
- Access local files on the file systems, for example to source configuration files
- Invoke local editors to edit textarea
- Invoke local applications, for example video player, on given page content.

However, native messenger's exposure is dangerous as it can be utilized by attackers.  Currently I don't use native messenger at my site.

For consistent text-based configuration, tridactyl allows reading it from and saving it to clipboard, which does not need the help of native messenger. The commands are respectively
#+begin_src vimrc
  mktridactylrc --clipboard
  source --clipboard
#+end_src

My configuration is:
#+begin_src vimrc
  " General Settings
  set hintchar "uhetonasid"
  set theme default

  " Binds
  bind ZZ composite sanitise tridactyllocal tridactylsync; qall
  bind --mode=ex          <C-n>   ex.next_completion
  bind --mode=ex          <C-p>   ex.prev_completion

  " Autocmds
  autocmd BeforeRequest https://bbs.saraba1st.com/* (details) => {let url = new URL(details.url); url.hostname = "stage1st.com"; return {redirectUrl: url + ""}; }

  " search engines
  set searchurls.archpack https://www.archlinux.org/packages/?sort=&q=%s&maintainer=&flagged=
  set searchurls.archwiki https://wiki.archlinux.org/index.php?search=%s&title=Special:Search&go=Go
  set searchurls.aur https://aur.archlinux.org/packages/?O=0&K=
  set searchurls.librs https://lib.rs/search?q=
  set searchurls.guix https://packages.guix.gnu.org/search/?query=
  set searchurls.whereis https://toys.whereis.social/?search=
  set searchurls.melpa https://melpa.org/#/
#+end_src
* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :lexical t :tangle "build/init.el"
:header-args:lisp-data: :tangle "build/templates.eld"
:header-args:scheme: :noweb-ref emacs-service
:END:
TODO: I'm still not sure if I should put some config as big as Emacs' in this file.

Implement a =home-emacs-service-type= that
- The service itself defines the Emacs version to use and the "Emacs compiler" to use, via =home-emacs-configuration=
- The service's extension add Emacs packages to use, configuration file to link, etc, via =home-emacs-extension=.
The reason for this set-up is
- I can easily swap between different Emacs versions, and packages will be automatically transformed to using that version's byte-codes.
- Configurations are discrete by using extensions, so they fit this literature configuration set-up better.
#+begin_src scheme :tangle "build/hiecaq/home/services/emacs.scm" :noweb-ref nil
  (define-module (hiecaq home services emacs)
    #:use-module (gnu services)
    #:use-module (gnu services configuration)
    #:use-module (gnu home services)
    #:use-module (gnu home services xdg)
    #:use-module ((gnu packages emacs) #:prefix upstream:)
    #:use-module (guix packages)
    #:use-module (srfi srfi-1)
    #:export (home-emacs-configuration
              home-emacs-extension
              home-emacs-service-type))

  (define-configuration/no-serialization home-emacs-configuration
    (emacs
     (package upstream:emacs)
     "Emacs to use.")
    (emacs-compiler
     (package upstream:emacs-minimal)
     "Emacs used for compiling packages.")
    (packages
     (list '())
     "List of Emacs packages to use.")
    (rewritten-packages
     (alist '())
     "Alist of rewrites from upstream package to local definitions.")
    (configs
     (alist '())
     "Emacs configuration files."))

  (define (home-emacs-transformed-package config)
    (package-input-rewriting
     `((,upstream:emacs-minimal
        . ,(home-emacs-configuration-emacs-compiler config))
       (,upstream:emacs-no-x
        . ,(home-emacs-configuration-emacs config))
       (,upstream:emacs
        . ,(home-emacs-configuration-emacs config))
       ,@(home-emacs-configuration-rewritten-packages config))))

  (define (home-emacs-profile config)
    `(,(home-emacs-configuration-emacs config)
      ,@(map cdr (home-emacs-configuration-rewritten-packages config))
      ,@(map (home-emacs-transformed-package config)
             (home-emacs-configuration-packages config))))

  (define-configuration/no-serialization home-emacs-extension
    (packages
     (list '())
     "Extra list of Emacs packages to use.")
    (rewritten-packages
     (alist '())
     "Alist of rewrites from upstream package to local definitions.")
    (configs
     (alist '())
     "Extra Emacs configuration files."))

  (define (home-emacs-extensions original-config extension-configs)
    (let ((append-fields
           (lambda (config-getter extension-getter)
             (append (config-getter original-config)
                     (append-map extension-getter extension-configs)))))
      (home-emacs-configuration
       (inherit original-config)
       (packages (append-fields home-emacs-configuration-packages
                                home-emacs-extension-packages))
       (rewritten-packages (append-fields home-emacs-configuration-rewritten-packages
                                          home-emacs-extension-rewritten-packages))
       (configs (append-fields home-emacs-configuration-configs
                               home-emacs-extension-configs)))))

  (define home-emacs-service-type
    (service-type
     (name 'home-emacs)
     (extensions
      (list (service-extension home-xdg-configuration-files-service-type
                               home-emacs-configuration-configs)
            (service-extension home-profile-service-type
                               home-emacs-profile)
            (service-extension home-environment-variables-service-type
                               (const '(("EDITOR" . "emacsclient -a nvim -c")
                                        ("VISUAL" . "emacsclient -a nvim -c"))))
            ;; See bug#74467
            (service-extension home-xdg-mime-applications-service-type
                               (const (home-xdg-mime-applications-configuration
                                       (default '((x-scheme-handler/org-protocol . emacsclient-uri.desktop)))
                                       (desktop-entries
                                        (list (xdg-desktop-entry
                                               (file "emacsclient-uri")
                                               (name "Emacs (Client) for URI handling")
                                               (type 'application)
                                               (config '((terminal . #f)
                                                         (exec . "emacsclient --alternate-editor= -- %u")))))))))))
     (compose identity)
     (extend home-emacs-extensions)
     (default-value (home-emacs-configuration))
     (description #f)))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/home/emacs.scm" :noweb yes :noweb-ref nil
  (define-module (hiecaq home emacs)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module ((gnu packages emacs) #:prefix upstream:)
    #:use-module (gnu home services)
    #:use-module (gnu home services shells)
    #:use-module (hiecaq home services emacs)
    #:use-module (guix gexp))

  (define-public services
    (list
     <<emacs-service>>))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home emacs) #:prefix emacs:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  emacs:services
#+end_src

** Basics
I'm currently using =emacs= from Guix official channel.
#+begin_src scheme
  (service home-emacs-service-type
           (home-emacs-configuration
            (emacs upstream:emacs-next)
            (emacs-compiler upstream:emacs-next-minimal)))
#+end_src

My Guix packages definition is at =(hiecaq packages emacs-xyz)=. TODO: makes a channel!
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-module (hiecaq packages emacs-xyz)
    #:use-module (guix utils)
    #:use-module (guix gexp)
    #:use-module (guix packages)
    #:use-module (guix git-download)
    #:use-module (guix build utils)
    #:use-module (guix build-system emacs)
    #:use-module (gnu packages)
    #:use-module ((gnu packages textutils) #:prefix upstream:) ;; for vale
    #:use-module ((gnu packages emacs) #:prefix upstream:)
    #:use-module ((gnu packages emacs-xyz) #:prefix upstream:)
    #:use-module ((guix licenses) #:prefix license:))
#+end_src

NOTE: the hash for git-based packages is got by following [[https://guix.gnu.org/cookbook/en/html_node/Extended-example.html][Guix Cookbook instructions]].

** Early Initialization
:PROPERTIES:
:header-args:emacs-lisp: :lexical t :tangle "build/early-init.el"
:END:

#+begin_src scheme
  (simple-service
   'home-emacs-early-init
   home-emacs-service-type
   (home-emacs-extension
    (configs `(("emacs/early-init.el" ,(local-file "../../early-init.el"))))))
#+end_src

#+begin_src emacs-lisp :comments no
  ;;; early-init.el --- Configurations before package systems and UI systems -*- lexical-binding: t; buffer-read-only: t; eval: (auto-revert-mode 1) -*-
#+end_src

*** Packages
I don't use the built-in =package.el= to fetch packages, so I'll turn it off:
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

*** Special Key Remapping
grabbed from [[https://emacsnotes.wordpress.com/2022/09/11/three-bonus-keys-c-i-c-m-and-c-for-your-gui-emacs-all-with-zero-headache/][Three bonus keysC-i, C-m and C-[for your GUI Emacs; all with zero headache]]
#+begin_src emacs-lisp
  (add-hook
   'after-make-frame-functions
   (defun setup-blah-keys (frame)
     (with-selected-frame frame
       (when (display-graphic-p)
         (define-key input-decode-map (kbd "C-i") [CTRL-i])
         (define-key input-decode-map (kbd "C-[") [CTRL-lsb]) ; left square bracket
         (define-key input-decode-map (kbd "C-m") [CTRL-m])))))
#+end_src

*** Fonts
#+begin_src emacs-lisp
  (defun my-faces-initialize (frame)
    "Initialize faces when the first graphic display is available."
    (with-selected-frame frame
      (when (display-graphic-p)
        (let* ((families (font-family-list))
               (family-p (lambda (family) (member family families)))
               (first-family-installed
                (lambda (family-list)
                  (seq-find family-p family-list))))

          (when-let* ((family
                       (funcall first-family-installed '("Hack Nerd Font Mono"
                                                         "Hack"
                                                         "Noto Sans Mono"))))
            (set-face-attribute 'default nil :family family))

          (when-let* ((family
                       (funcall first-family-installed '("Noto Sans"
                                                         "Sans Serif"))))
            (set-face-attribute 'variable-pitch nil :family family))

          (when (eq system-type 'gnu/linux)
            (set-face-attribute 'default nil :height 140))

          (when-let* ((family
                       (funcall first-family-installed '("Noto Sans CJK SC"))))
            (set-fontset-font t 'han (font-spec :family "Noto Sans CJK SC")))

          (when-let* ((family
                       (funcall first-family-installed '("Noto Sans CJK JP"))))
            (set-fontset-font t 'kana (font-spec :family "Noto Sans CJK JP")))

          (when-let* ((family
                       (funcall first-family-installed '("Noto Sans CJK SC"))))
            (set-fontset-font t 'cjk-misc (font-spec :family "Noto Sans CJK SC"))))

        (set-face-attribute 'variable-pitch nil :weight 'normal :inherit 'default)
        (set-face-attribute 'fixed-pitch nil    :family  (internal-get-lisp-face-attribute 'default :family))

        (remove-hook 'after-make-frame-functions #'my-faces-initialize))))

  (add-hook 'after-make-frame-functions #'my-faces-initialize)
#+end_src

*** Some Configurations that might make sense to put here
~load~ prefers the newest version of a file (when suffix is not given).
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

#+begin_src emacs-lisp
  (setq load-no-native t)
#+end_src

** Main Configurations
#+begin_src scheme
  (simple-service
   'home-emacs-init
   home-emacs-service-type
   (home-emacs-extension
    (configs `(("emacs/init.el" ,(local-file "../../init.el"))))))
#+end_src

Init file header:
#+begin_src emacs-lisp :comments no
  ;;; init.el --- Main Configurations -*- lexical-binding: t; buffer-read-only: t; eval: (auto-revert-mode 1) -*-
#+end_src

Use Utf-8 as the default coding system.
#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8-unix)
#+end_src

*** Packages
On Android and Windows, I currently just use =package.el=, because Guix doesn't support them (yet?).
#+begin_src emacs-lisp :noweb yes
  (setopt package-archives
          (if (eq system-type 'gnu/linux)
              nil
            '(("gnu"    . "https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/")
              ("nongnu" . "https://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/")
              ("melpa"  . "https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"))))

  (defvar package-selected-packages '<<current-selected-packages()>>)

  (when package-archives
    (package-initialize))
#+end_src

On Linux when I tangle the =init.el=, my generated ~package-selected-packages~ will contains the packages I need on these platforms.  Then after the Emacs on these platforms loading my =init.el=, I can manually call ~package-install-selected-packages~ to get them installed.
#+name: current-selected-packages
#+begin_src elisp :exports none
  package-selected-packages
#+end_src

*** setup.el
[[https://www.emacswiki.org/emacs/SetupEl][setup.el]] provides "context sensitive local macros" to "ease repetitive configuration patterns in Emacs". It is considered as an alternative to the now built-in [[https://github.com/jwiegley/use-package][use-package]].
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list (specification->package
            "emacs-setup")))))
#+end_src

See Alternative Macro Definer at [[https://www.emacswiki.org/emacs/SetupEl][its Emacs Wiki page]], and [[https://github.com/mfiano/emacs-config/blob/main/lisp/mf-setup.el][Michael Fiano's Emacs Configuration on this]]. Many of the following tweaks are based on them, with some modifications, mainly for the Emacs 29 changes.

TODO: I should split this out later.
#+begin_src emacs-lisp
  (require 'setup)
  (require 'cl-macs)

  (defmacro defsetup (name signature &rest body)
    "Shorthand for `setup-define'.
  NAME is the name of the local macro.  SIGNATURE is used as the
  argument list for FN.  If BODY starts with a string, use this as
  the value for :documentation.  Any following keywords are passed
  as OPTS to `setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
        (setq opts (nconc (list :documentation (pop body))
                          opts)))
      (while (keywordp (car body))
        (let* ((prop (pop body))
               (val `',(pop body)))
          (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
         (cl-function (lambda ,signature ,@body))
         ,@opts)))

  (put #'defsetup 'lisp-indent-function 'defun)
  ;; use Emacs 29's new `setopt'
  (setup-define :option
    (setup-make-setter
     (lambda (name)
       `(funcall (or (get ',name 'custom-get)
                     #'symbol-value)
                 ',name))
     (lambda (name val)
       `(setopt ,name ,val)))

    :documentation "Set the option NAME to VAL.
  NAME may be a symbol, or a cons-cell.  If NAME is a cons-cell, it
  will use the car value to modify the behaviour.  These forms are
  supported:

  (append VAR)    Assuming VAR designates a list, add VAL as its last
                  element, unless it is already member of the list.

  (prepend VAR)   Assuming VAR designates a list, add VAL to the
                  beginning, unless it is already member of the
                  list.

  (remove VAR)    Assuming VAR designates a list, remove all instances
                  of VAL.

  Note that if the value of an option is modified partially by
  append, prepend, remove, one should ensure that the default value
  has been loaded. Also keep in mind that user options customized
  with this macro are not added to the \"user\" theme, and will
  therefore not be stored in `custom-set-variables' blocks."
    :debug '(sexp form)
    :repeatable t)

  (defsetup :global (&rest body)
    "Use the global keymap for the BODY. This is intended to be used with ':bind'."
    :debug '(sexp)
    (let (bodies)
      (push (setup-bind body (map 'global-map))
            bodies)
      (macroexp-progn (nreverse bodies))))

  (defsetup :with-state (state &rest body)
    "Change the evil STATE that BODY will bind to. If STATE is a list, apply BODY
  to all elements of STATE. This is intended to be used with ':bind'."
    :indent 1
    :debug '(sexp setup)
    (let (bodies)
      (dolist (state (ensure-list state))
        (push (setup-bind body (state state))
              bodies))
      (macroexp-progn (nreverse bodies))))

  (defsetup :bind (key command)
    "Bind KEY to COMMAND in current map, and optionally for current evil states."
    :after-loaded t
    :debug '(form sexp)
    :repeatable t
    (let* ((map (setup-get 'map))
           (global (or (not map) (eq map 'global) (eq map 'global-map)))
           (state (ignore-errors (setup-get 'state))))
      (cond
       ((and state global)
        `(with-eval-after-load 'evil
           (evil-define-key* ',state 'global ,(kbd key) ,command)))
       (state
        `(with-eval-after-load 'evil
           (evil-define-key* ',state ,map ,(kbd key) ,command)))
       (global `(keymap-global-set ,key ,command))
       (t `(keymap-set ,map ,key ,command)))))

  (defsetup :unbind (key)
    "Unbind KEY in current map, and optionally for current evil states."
    :after-loaded t
    :debug '(form)
    :repeatable t
    (let* ((map (setup-get 'map))
           (global (or (not map) (eq map 'global) (eq map 'global-map)))
           (state (ignore-errors (setup-get 'state))))
      (cond
       ((and state global)
        `(with-eval-after-load 'evil
           (evil-define-key* ',state 'global ,(kbd key) nil)))
       (state
        `(with-eval-after-load 'evil
           (evil-define-key* ',state ,map ,(kbd key) nil)))
       (global `(keymap-global-unset ,key :remove))
       (t `(keymap-unset ,map ,key :remove)))))

  (defsetup :rebind (old-command new-command)
    "Bind NEW-COMMAND to OLD-COMMAND in current map,
  and optionally for current evil states."
    :after-loaded t
    :debug '(form sexp)
    :repeatable t
    :ensure (func func)
    (let ((old-command-string
           (cadr (delete "#'" (split-string (format "%s" old-command) "#'")))))
      `(:bind ,(format "<remap> <%s>" old-command-string) ,new-command)))

  (defsetup :needs (executable)
    "If EXECUTABLE is not in the path, stop here."
    :debug '(form)
    `(unless (executable-find ,executable)
       ,(setup-quit)))

  (defsetup :enable ()
    "Enable the current mode."
    :debug '(form)
    `(,(setup-get 'mode) 1))

  (defsetup :system (type)
    "If system-type is not TYPE, stop here."
    :debug '(form)
    :repeatable t
    `(unless (eq system-type ,type)
       ,(setup-quit)))

  (defsetup :package (package)
    "Push PACKAGE into package-selected-packages."
    :shorthand cadr
    `(add-to-list 'package-selected-packages ',package))

  (setup (:package setup))
#+end_src

*** Some Sane Configurations
#+begin_src emacs-lisp
  (setup simple
    (:option indent-tabs-mode nil))

  (setup frame
    (:option blink-cursor-mode nil))

  (setup scroll-bar
    (:option scroll-bar-mode nil))

  (setup tool-bar
    (:option tool-bar-mode nil))

  (setup menu-bar
    (:option menu-bar-mode nil))
#+end_src

Turn off lockfiles. They cannot be moved to a different directory, and they consistently screw up with file watchers and version control systems. It'd be just easier to turn this feature off.
#+begin_src emacs-lisp
  (setup emacs
    (:option create-lockfiles nil))
#+end_src

4-space indentation:
#+begin_src emacs-lisp
  (setup simple
    (:option tab-width 4))
#+end_src

General programming set up:
#+begin_src emacs-lisp
  (setup prog-mode
    (:hook #'display-line-numbers-mode)
    (:local-set truncate-lines t))
#+end_src

When Emacs writes buffers to files, by the high-level sense it replace the existing file with the content in the buffer. The buffer itself can be backuped, so that if Emacs crashes before the writing, the dirty content can be recovered. How it replaces the content is configurable, and I want to always prefer copying the existing file and then writing the buffer on top of the existing file. See [[help:make-backup-files][help]] for details.
#+begin_src emacs-lisp
  (setup files
    (:option make-backup-files nil)
    (:option backup-by-copying t))
#+end_src

Always use =y-or-p= over =yes-or-no=, and use ~read-key~ instead of ~read-from-minibuffer~. The latter is helpful when using Embark.
#+begin_src emacs-lisp
  (setup emacs
    (:option use-short-answers t
             y-or-n-p-use-read-key t))
#+end_src

I don't want Emacs to auto-recenter when scrolling off-the-screen:
#+begin_src emacs-lisp
  (setup emacs
    (:option scroll-conservatively 108))
#+end_src

Emacs comes with a customization interface, which supports setting via function calls too (good!) and saves the results in a file (bad!).  Up until Emacs 29, I set the storage to =/dev/null=. Started from Emacs 30, I find that sometimes file-defined local variables are not loaded the first time I open a buffer, so I came up with a new solution: set it to a random temporary file every time Emacs starts.
#+begin_src emacs-lisp
  (setup cus-edit
    (:option custom-file null-device)
    (defun my-custom-file-set ()
      (:option custom-file
               (make-temp-file "emacs-custom-" nil ".el"
                               ";; auto-generated by custom-file\n")))
    (:with-function my-custom-file-set
      (:hook-into after-init)))
#+end_src

Don't show =*Warnings*= and just for those elisp compilation errors. Note that they are still logged into the buffer.  Stolen from [[https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/#h:5a631dfa-a8db-43f4-bd7a-92ce49c54226][Protesilaos Stavrou]]:
#+begin_src emacs-lisp
  (setup window
    (:option (prepend display-buffer-alist)
             `(,(rx bos "*" (or "Warnings" "Compile-Log") "*" eos)
               (display-buffer-no-window)
               (allow-no-window . t))))
#+end_src
Note that if ~switch-to-buffer-obey-display-actions~ is =t=, buffers matched to use ~display-buffer-no-window~ are basically hidden forever unless you use ~display-buffer-override-next-command~.

Allow word-wrap at any CJK character, otherwise it only wraps at spaces when there are also non-CJK characters in the physical lines, producing sparse visual lines.
#+begin_src emacs-lisp
  (setup emacs
    (:option word-wrap-by-category t))
#+end_src

Also, Emacs by default auto-renames certain buffers when a buffer with the same name is killed, which brings trouble to scripting. So I'd have this feature turned off.
#+begin_src emacs-lisp
  (setup uniquify
    (:option uniquify-after-kill-buffer-p nil))
#+end_src

I found some hacks [[https://emacs-china.org/t/topic/25811/9][here]] that speed up displaying long lines by sacrificing the compatibility of bidirectional text. I don't read or type bidirectional text myself,  and these hacks can be reverted on a per-buffer basis if necessary. I currently use just the one that is not subjected against in the documentation.
#+begin_src emacs-lisp
  (setup emacs
    (:option bidi-paragraph-direction 'left-to-right))
#+end_src

Time out on remote file access (in seconds), for example if they are offline, so that Emacs is not blocked forever.
#+begin_src emacs-lisp
  (setup files
    (:option remote-file-name-access-timeout 3))
#+end_src

**** Android
#+begin_src emacs-lisp
  (setup touch-screen
    (:system 'android)
    (:option overriding-text-conversion-style nil)
    (:option touch-screen-display-keyboard t))
#+end_src

*** Window Management
#+begin_src emacs-lisp
  (setup window
    (:option switch-to-buffer-obey-display-actions t
             switch-to-buffer-in-dedicated-window 'pop
             ;; left, top, right, bottom
             window-sides-slots '(0 0 1 1))
    (defun fit-window-to-buffer-horiz (window)
      "Fit window to buffer horizontally. Suitable for `window-width'."
      (let ((fit-window-to-buffer-horizontally 'only))
        (fit-window-to-buffer window))))
#+end_src

#+begin_src emacs-lisp
  (defun my-window-shot (&optional window)
    "Take screenshot of a given Emacs window."
    (interactive)
    (pcase-let ((`(,window-left ,window-top ,window-right ,window-bottom)
                 (window-edges (window-normalize-window window t) nil t t)))
      (let* ((geo (format "%dx%d+%d+%d"
                          (- window-right window-left)
                          (- window-bottom window-top)
                          window-left
                          window-top))
             (file (expand-file-name (format "%f.jpg" (time-to-seconds (time-since 0)))
                                     (xdg-user-dir "PICTURES"))))
        (make-process :name "window-shot"
                      :command `("maim"
                                 "-m" "10"
                                 "--geometry" ,geo
                                 ,file)))))
#+end_src

#+begin_src emacs-lisp
  (defvar my-window-record--process nil "Running record process")
  (defun my-window-record (&optional window sec)
    "Take screen record of a given Emacs window."
    (interactive)
    (if (process-live-p my-window-record--process)
        (process-send-string my-window-record--process "q")
      (pcase-let ((`(,window-left ,window-top ,window-right ,window-bottom)
                   (window-edges (window-normalize-window window t) nil t t)))
        (let* ((size (format "%dx%d"
                             (- window-right window-left)
                             (- window-bottom window-top)))
               (geo (format ":0.0+%d,%d"
                            window-left
                            window-top))
               (file (expand-file-name (format "%f.mp4" (time-to-seconds (time-since 0)))
                                       (xdg-user-dir "PICTURES")))
               (proc (make-process :name "window-record"
                                   :buffer "*window-record*"
                                   :connection-type 'pty
                                   :command `("ffmpeg"
                                              "-video_size" ,size
                                              "-framerate" "8"
                                              "-f" "x11grab"
                                              "-i" ,geo
                                              ,file))))
          (setq my-window-record--process proc)
          (unless (null sec)
            (run-with-timer sec nil
                            #'process-send-string proc "q"))))))
#+end_src

*** Universal Argument
I am using [[https://www.kaufmann.no/roland/dvorak/][Programmer Dvorak (DVP)]], which swaps digits and special symbols. This makes typing numbers generally inconvenient. The idea behind this change is that we should define ~const~ variables to hold these numbers to reduce the chances we need to actually type numbers. However, Emacs (and Evil) use numbers to repeat commands, a situation that we still need typing digits directly. This is improved by the following tweak.

=C-u= basically invokes the ~unversal-argument-map~ transient map, so we can remap the digit row's symbols to actual digits. Also I add a binding to insert current universal argument's number.
#+begin_src emacs-lisp
  (defvar my-dvp-digit-row-alist
    '((7 . "[")
      (5 . "{")
      (3 . "}")
      (1 . "(")
      (9 . "=")
      (0 . "*")
      (2 . ")")
      (4 . "+")
      (6 . "]")
      (8 . "!"))
    "`Higher' case characters to digits mapping on dvorak digit row")

  (setup simple
    (defun my-digit-argument (digit)
      "Return the command that inputs the given
  digit as universal argument."
      (lambda (arg)
        (interactive "P")
        (let ((last-command-event (+ digit ?0)))
          (digit-argument arg))))
    (:with-map universal-argument-map
      (dolist (d (number-sequence 0 9))
        (:bind (alist-get d my-dvp-digit-row-alist)
               (my-digit-argument d)))
      (:bind "<CTRL-i>" (lambda (arg)
                          (interactive "P")
                          (insert (format "%s" arg))))))
#+end_src

Also here is a helper macro for binding commands. I personally do not like using universal argument at all.
#+begin_src emacs-lisp
  (defmacro my-with-universal-argument (cmd)
    "Wrap the given CMD with a lambda that set universal argument before
    interactively calling CMD."
    `(lambda ()
       (interactive)
       (let ((current-prefix-arg '(4)))
         (call-interactively ,cmd))))
#+end_src

*** PCRE
Emacs comes with an [[info:elisp#Rx Notation][Rx Notation]] that converts sexp DSL in that format into Emacs Regex strings. However, Emacs' regex format is a little bit different from PCRE, the most prevalent regex standard among tools outside of Emacs. [[https://github.com/joddie/pcre2el][pcre2el]] is the missing bridge between PCRE, Emacs regex string and rx notation.
#+begin_src scheme
  (simple-service
   'home-emacs-pcre
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-pcre2el")))))
#+end_src
*** Help
TODO: this should not require help.
#+begin_src emacs-lisp
  (setup (:require help)
    (:global (:unbind "C-h C-h")))
#+end_src

*** Info
Info is a built-in Texinfo browser.
#+begin_src emacs-lisp
  (setup info
    (:local-set truncate-lines t))
#+end_src

Starting from Emacs 30, we can open the corresponding web page of Info node by ~Info-goto-node-web~.  The variable that dispatches this command is
#+begin_src emacs-lisp
  (setup info
    (:when-loaded
      (:option (prepend* Info-url-alist)
               '((("guix") . "https://guix.gnu.org/manual/devel/en/html_node/%e")
                 (("guile") . "https://www.gnu.org/software/guile/manual/html_node/%e")))))
#+end_src

In order to handle single-paged manuals, I have this help function:
#+begin_src emacs-lisp
  (setup info
    (defun my-info-url-alist-single-page-entry (url-spec)
      (lambda (manual node encoded-node)
        (concat (format-spec url-spec
                             `((?m . ,manual) (?n . ,node) (?e . ,encoded-node)))
                "#" (string-remove-suffix ".html" encoded-node)))))
#+end_src

*** Xdg
#+begin_src emacs-lisp
  (setup (:require xdg))
#+end_src


*** No Littering
[[https://github.com/emacscollective/no-littering][no-littering]] helps put emacs directory clean, sorting package-created files and directories into reasonable directories. One thing it misses is the distinguishing between permanent data and temporary data. I used to fork it to provide this distinguishing, but it turns out to be too troublesome to maintain. Now I simply consider this as a "fallback" solution. Later on for the variables from packages I really use I'll overwrite them manually.
#+begin_src scheme
  (simple-service
   'home-emacs-no-littering
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-no-littering")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package no-littering)
    (:require no-littering))
#+end_src

#+begin_src emacs-lisp
  (defmacro def-exdg-home-dir (xdg-name)
    (list 'progn
          `(defvar ,(intern (format "exdg-%s-dir" xdg-name))
             (expand-file-name (convert-standard-filename "emacs/") (,(intern (format "xdg-%s-home" xdg-name)))))
          `(defun ,(intern (format "exdg-%s" xdg-name)) (file)
             (expand-file-name (convert-standard-filename file) ,(intern (format "exdg-%s-dir" xdg-name))))))

  (def-exdg-home-dir config)
  (def-exdg-home-dir cache)
  (def-exdg-home-dir data)
  (def-exdg-home-dir state)

  (setq exdg-config-dir (expand-file-name "config/" user-emacs-directory))
#+end_src

*** Modus Themes
#+begin_src scheme
  (simple-service
   'home-emacs-modus-themes
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-modus-themes")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package modus-themes)
    (:option modus-themes-mixed-fonts t)
    (:require modus-themes)
    (load-theme 'modus-vivendi :no-confirm))
#+end_src

*** Mode Line
#+begin_src emacs-lisp
  (defvar-local my-mode-line-format nil
    "My `mode-line-format', for easy toggle between the default version.")

  (defun my-toggle-mode-line-format ()
    (interactive)
    (let* ((standard (eval (car (get 'mode-line-format 'standard-value))))
           (new-format (if (eq standard (default-value 'mode-line-format))
                           my-mode-line-format
                         standard)))
      (setq-default mode-line-format new-format)
      (kill-local-variable 'mode-line-format)
      (force-mode-line-update)))

  (defun my-mode-line-recursion--indicator ()
    (when-let (((mode-line-window-selected-p))
               (depth (- (recursion-depth) (if (active-minibuffer-window) 1 0)))
               ((> depth 0)))
      (format "R%d" depth)))

  (defvar-local my-mode-line-recursion-indicator
      '(:eval (my-mode-line-recursion--indicator)))
  (put 'my-mode-line-recursion-indicator 'risky-local-variable t)

  (defvar-local my-mode-line-indicators (list my-mode-line-recursion-indicator
                                              '(:eval (when find-file-literally "L "))
                                              '(:eval (when buffer-read-only "RO "))
                                              '(:eval (unless (string-equal (format-mode-line "%@") "-") "Remote "))
                                              '(:eval (when (buffer-narrowed-p) '(:propertize "Narrow " face warning)))
                                              '(:eval (when (window-dedicated-p) "Dedi "))
                                              '(:eval (when (window-parameter (selected-window) 'window-side) "Side "))
                                              '(current-input-method current-input-method-title)
                                              '(god-local-mode "God ")
                                              '(defining-kbd-macro "Def ")
                                              '(flymake-mode flymake-mode-line-format)
                                              '(:eval (when (buffer-modified-p) "M "))
                                              '(:eval (unless (eq evil-state 'normal)
                                                        (string-trim evil-mode-line-tag))))
    "A list of mode line indicators that is displayed on active window.")

  (put 'my-mode-line-indicators 'risky-local-variable t)

  (setopt my-mode-line-format '("%e"
                                mode-line-front-space
                                nil ;; eshell
                                (:eval (when (mode-line-window-selected-p)
                                         (list my-mode-line-indicators
                                               mode-line-misc-info)))

                                mode-line-format-right-align

                                mode-line-buffer-identification
                                (vc-mode vc-mode)
                                " "
                                mode-name
                                mode-line-end-spaces))

  (setup bindings
    (:option mode-line-buffer-identification (propertized-buffer-identification "%b")
             mode-line-format my-mode-line-format
             mode-line-right-align-edge 'right-fringe))
#+end_src

*** Midnight
=midnight= is Emacs' built-in cron-like service that run once during midnight each day. Its main purpose is to do same maintenance for the Emacs instance, such as cleaning very old unused buffers. It simply invokes ~midnight-hook~ (which contains ~#'clean-buffer-list~ by default) ~midnight-delay~ seconds after the midnight.

#+begin_src emacs-lisp
  (setup midnight
    (:option midnight-delay (* 4 60 60))
    (:enable))
#+end_src

*** Auto Save
#+begin_src emacs-lisp
  (setup files
    (let ((autosave-dir (exdg-cache "auto-save/")))
      (mkdir autosave-dir t)
      (:option auto-save-file-name-transforms
               `(("\\`/[^/]*\\([^/]*/\\)*\\([^/]*\\)\\'" ,(concat autosave-dir "\\2") t)))))
#+end_src

*** Recentf
[[info:emacs#File Conveniences][recentf]] is an Emacs built-in minor mode that saves recent file list.
#+begin_src emacs-lisp
  (setup recentf
    (:option recentf-save-file (exdg-state "recentf-save.el"))
    (:enable))
#+end_src

*** Save History
[[help:savehist-mode][savehist]] is an Emacs built-in minor mode that save minibuffer histories to a file.
#+begin_src emacs-lisp
  (setup savehist
    (:option savehist-file (exdg-state "savehist.el"))
    (:enable))
#+end_src

***  COMMENT Save Place
[[https://www.emacswiki.org/emacs/SavePlace][Save Place]] is a Emacs built-in mode that "nave place in files between sessions".
#+begin_src emacs-lisp
  (setup saveplace
    (:option save-place-forget-unreadable-files nil)
    (save-place-mode 1))
#+end_src

*** Editorconfig
[[https://editorconfig.org/][editorconfig]] is a very handy tool that standardize how different editors should behave according to different language, including tab width, trailing space and so on. It is not only helpful for team to maintain a codestyle standard, but also a handful tool for people use several different editors / computers, like I do.

[[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] implements its own =editorconfig= core, so it's logical to assume that it works on any platform. It is built-in since Emacs 30.
#+begin_src emacs-lisp
  (setup editorconfig
    (:enable))
#+end_src

*** Envrc
[[https://github.com/purcell/envrc][envrc]] is Emacs' integration with [[https://direnv.net/][direnv]] that works in buffer-local style.

[[https://github.com/purcell/inheritenv][interitenv]].
#+begin_src scheme
  (simple-service
   'home-emacs-envrc
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-envrc")
      (specification->package
       "emacs-inheritenv")))))
#+end_src

#+begin_src emacs-lisp
  (setup envrc
    (:system 'gnu/linux)
    (:also-load inheritenv)
    (:with-mode envrc-global-mode
      (:hook-into after-init)))
#+end_src


*** Subword
[[help:subword-mode][subword-mode]] is an Emacs built-in that makes =CamelCase= be considered as 2 separate words =Camel= and =Case=. Evil also respects this minor mode. I've found that to turn on this mode is almost always positive for Evil usages, because the =io= =ao= text objects select the whole symbol anyway, pretty much covers the non-subword usage. There is also [[help:superword-mode][superword-mode]] BTW. See [[info:emacs#MixedCase Words][MixedCase Words]] and [[info:emacs#Misc for Programs][Misc for Programs]] in the documentation.
#+begin_src emacs-lisp
  (setup subword
    (:hook-into text-mode prog-mode))
#+end_src

*** Highlight Parentheses
[[https://git.sr.ht/~tsdh/highlight-parentheses.el][highlight-parentheses]], well, highlights parentheses surrounding [[info:emacs#Point][point]].
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-highlight-parentheses
    (let ((version "2.2.2")
          (revision "0")
          (url "https://git.sr.ht/~tsdh/highlight-parentheses.el"))
      (package
        (name "emacs-highlight-parentheses")
        (version version)
        (source
         (origin
           (method git-fetch)
           (uri
            (git-reference
             (url url)
             (commit version)))
           (file-name (git-file-name name version))
           (sha256
            (base32 "0wvhr5gzaxhn9lk36mrw9h4qpdax5kpbhqj44745nvd75g9awpld"))))
        (build-system emacs-build-system)
        (home-page url)
        (synopsis "Highlights parentheses surrounding point in Emacs")
        (description "Highlight-parentheses.el dynamically highlights
  the parentheses surrounding point based on nesting-level using configurable
  lists of colors, background colors, and other properties.")
        (license license:gpl3))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-highlight-parentheses
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-highlight-parentheses")))))
#+end_src

The configs here is basically from [[https://protesilaos.com/emacs/modus-themes#h:24bab397-dcb2-421d-aa6e-ec5bd622b913][Note on highlight-parentheses.el]] in Modus Themes documentation, modified a little bit.
#+begin_src emacs-lisp
  (setup (:package highlight-parentheses)
    (defvar my-highlight-parentheses-use-background t
      "Prefer `highlight-parentheses-background-colors'.")

    (setq my-highlight-parentheses-use-background t) ; Set to nil to disable backgrounds

    (modus-themes-with-colors
      ;; Our preference for setting either background or foreground
      ;; styles, depending on `my-highlight-parentheses-use-background'.
      (if my-highlight-parentheses-use-background

          ;; Here we set color combinations that involve both a background
          ;; and a foreground value.
          (setq highlight-parentheses-background-colors (list bg-cyan-intense
                                                              bg-magenta-intense
                                                              bg-green-intense
                                                              bg-yellow-intense)
                highlight-parentheses-colors (list cyan
                                                   magenta
                                                   green
                                                   yellow))

        ;; And here we pass only foreground colors while disabling any
        ;; backgrounds.
        (setq highlight-parentheses-colors (list green-intense
                                                 magenta-intense
                                                 blue-intense
                                                 red-intense)
              highlight-parentheses-background-colors nil)))
    (:hook-into prog-mode)
    (:with-function highlight-parentheses-minibuffer-setup
      (:hook-into minibuffer-setup)))
#+end_src

*** Transient
#+begin_src emacs-lisp
  (setup transient
    (:option transient-history-file (exdg-state "transient/history.el")
             transient-levels-file (exdg-state "transient/levels.el")
             transient-values-file (exdg-state "transient/values.el")))
#+end_src

*** Evil
It's name tells everything: the Extensible Vi Layer for Emacs, [[https://github.com/emacs-evil/evil][Evil]]. It works pretty well as a Vim simulation, much better than VsCode's or Intellij's. Besides, it is charming combination of Vim's model-based editing with Emacs' keymap system, to some extent, as a personal opinion, better than the native Vim on the model-based editing system.

References:
- [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid
#+begin_src scheme
  (simple-service
   'home-emacs-evil
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          (list
           "emacs-goto-chg"
           "emacs-evil-collection-next"
           "emacs-evil-surround-next"
           "emacs-evil-snipe"
           "emacs-evil-commentary")))
    (rewritten-packages
     `((,(specification->package "emacs-evil") .
        ,(specification->package "emacs-evil-next"))))))
#+end_src


#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-next
    (let ((commit "c7043cc7731206aac93090ff266ba9343ed78b2c")
          (last-release-version "1.15.0")
          (revision "0"))
      (package
        (inherit upstream:emacs-evil)
        (name "emacs-evil-next")
        (version (git-version last-release-version revision commit))
        (source
         (origin
           (method git-fetch)
           (uri (git-reference
                 (url "https://github.com/hiecaq/evil")
                 (commit commit)))
           (file-name (git-file-name name version))
           (sha256
            (base32
             "1hzfp9sfvv4isgvbg9cicqhfqqrfzjrms27zn3vzdjqf6nyglxd1")))))))
#+end_src

[[https://github.com/noctuid/annalist.el][annalist]] is a dependency of =emacs-evil-collection=, and its test dependency [[https://github.com/abo-abo/lispy][lispy]] somehow fail to build under Emacs 30 because of test failures. I simply disable tests for  =annalist= and deletes all its test dependencies.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-annalist-minimal
    (package
      (inherit upstream:emacs-annalist)
      (name "emacs-annalist-minimal")
      (native-inputs '())
      (arguments (substitute-keyword-arguments
                     (package-arguments upstream:emacs-annalist)
                   ((#:tests? t) #f)))))
#+end_src

I need some latest contributions to the =evil-collection= repository:
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-collection-next
    (let ((commit "fca81ddb2ca1ac3838aa7e8969b2313712807a45")
          (last-release-version "0.0.10")
          (revision "0"))
      (package
       (inherit upstream:emacs-evil-collection)
       (name "emacs-evil-collection-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/emacs-evil/evil-collection")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0grp87nb9pxx47rzclhngqn9gvgbn39yfk0szz6a4xh0pf56f100"))))
       (propagated-inputs
        (modify-inputs (package-propagated-inputs upstream:emacs-evil-collection)
                       (replace "emacs-annalist" emacs-annalist-minimal))))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package evil)
    (:option
     evil-want-integration t ;; require by collection
     evil-want-keybinding nil ;; require by collection
     evil-echo-state nil ;; Don't echo the =<INSERT>= etc info in minibuffer.
     evil-undo-system 'undo-redo ;; Use Emacs 28 new ~undo-redo~ as the undo-redo system
     evil-disable-insert-state-bindings t ;; I don't want to use Vim's insert mode bindings in insert state:
     evil-respect-visual-line-mode t ;; When =visual-line-mode= is set (especially in =org-mode=), I want Vim to behave as visual lines are normal lines (i.e. bind =j= to =gj= etc)
     evil-mode-line-format nil
     evil-search-module 'evil-search)
    (:require evil)
    (:enable)
    (:global
     (:with-state (motion insert)
       (:unbind "C-z"))
     (:with-state (normal)
       (:bind "<CTRL-i>" #'evil-jump-forward))))

  (setup (:package evil-collection)
    (:option evil-collection-setup-minibuffer t
             evil-collection-key-blacklist '("SPC" "C-SPC" "DEL" "C-z"))
    (:require evil-collection)
    (evil-collection-init))
#+end_src

I don't really use =;= at all, so I map it to ~evil-avy-goto-char-2~, which has the functionality similar to =vim-sneak=. I switched from =s= to =;= because overriding it for Magit is kind of hard, and it is even harder to come up with a new mnemonic for "staging".
#+begin_src emacs-lisp
  (setup evil
    (:global
     (:with-state (normal motion operator visual)
       (:bind ";" #'evil-avy-goto-char-2))))
#+end_src
And Dired EPA integration's keybindings conflicts with =;=, so I'd like to unbind them:
#+begin_src emacs-lisp
  (setup dired
    (:with-state (normal)
      (:unbind ";")))
#+end_src

**** Noun-Verb Editing
See [[https://www.hiecaq.org/posts/20250409T225608M449.html][my blog post]] for details.
#+begin_src emacs-lisp
  (setup evil
    (defun my-evil-inner-thing ()
      (interactive)
      (evil-visual-char)
      (set-transient-map evil-inner-text-objects-map))

    (defun my-evil-outer-thing ()
      (interactive)
      (evil-visual-char)
      (set-transient-map evil-outer-text-objects-map))

    (:global
     (:with-map (evil-operator-state-map evil-visual-state-map)
       (:unbind "a" "i")
       (:bind "." evil-inner-text-objects-map
              "," evil-outer-text-objects-map
              "a" #'evil-append
              "i" #'evil-insert))
     (:with-state (normal)
       (:bind "." #'my-evil-inner-thing
              "," #'my-evil-outer-thing
              "#" #'evil-repeat))))
#+end_src

**** Move up and down a list
#+begin_src emacs-lisp
  (setup evil
    (:global
     (:with-state (motion)
       (:bind "-" #'backward-up-list
              "+" #'down-list))))
#+end_src

**** Evil Surround
[[https://github.com/emacs-evil/evil-surround][evil-surround]] defines operators that change/add/delete delimiters around a text object.
I remap them all to =s= for better consistency.
#+begin_src emacs-lisp
  (setup (:package evil-surround)
    (:with-state (operator visual)
      (:unbind "s" "S" "g S"))
    (:with-state (normal operator)
      (:bind "s" #'evil-surround-edit
             "S" #'evil-Surround-edit))
    (:with-state visual
      (:bind "s" #'evil-surround-region
             "S" #'evil-Surround-region))
    (:also-load evil)
    (:with-function turn-on-evil-surround-mode
      (:hook-into prog-mode text-mode wdired-mode comint-mode eshell-mode minibuffer-setup))
    (define-advice wdired-change-to-dired-mode (:after (&rest _) turn-off-evil-surround)
      "`wdired-mode-hook' is only called when activated, so we have to do this manually when deactivating."
      (turn-off-evil-surround-mode)))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-surround-next
    (let ((commit "da05c60b0621cf33161bb4335153f75ff5c29d91")
          (last-release-version "1.0.4")
          (revision "0"))
      (package
        (inherit upstream:emacs-evil-surround)
        (name "emacs-evil-surround-next")
        (version (git-version last-release-version revision commit))
        (source
         (origin
           (method git-fetch)
           (uri (git-reference
                 (url "https://github.com/emacs-evil/evil-surround")
                 (commit commit)))
           (file-name (git-file-name name version))
           (sha256
            (base32
             "0wgxwvndhfaf0ha4pm392vj6yqyv2431hmvyivp1q16crd5g6bq5")))))))
#+end_src

**** Evil Replace With Register
[[https://github.com/Dewdrops/evil-ReplaceWithRegister][evil-replace-with-register]] defines a =replace= operator. However, we can implement its functionality easily with Evil mode itself, see [[https://emacs-china.org/t/evil-replace-with-register/27638][this post]]. I add some simple code to the solution there to make =""= register work as the way I want.
#+begin_src emacs-lisp
  (evil-define-operator my-evil-replace-with-register (count beg end type register)
    "Replacing an existing text with the contents of a register"
    :move-point nil
    (interactive "<vc><R><x>")
    (setq count (or count 1))
    (let ((saved (evil-get-register ?\")))
      (if (eq type 'block)
          (evil-visual-paste count register)
        (delete-region beg end)
        (evil-paste-before count register))
      (evil-set-register ?\" saved)))

  (setup evil
    (:global (:with-state (normal visual)
               (:bind "g s" #'my-evil-replace-with-register))))
#+end_src

**** Evil Snipe
[[https://github.com/hlissner/evil-snipe][evil-snipe]] is a Evil port of Vim's [[https://github.com/rhysd/clever-f.vim][clever-f]] and [[https://github.com/justinmk/vim-sneak][vim-sneak]]. It currently does not support separating the scope for =f/F/t/T= from for =s/S=, which is a little bit annoying.

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-snipe
    (let ((commit "16317d7e54313490a0fe8642ed9a1a72498e7ad2")
          (last-release-version "2.1.3") ;; from the el file version header
          (revision "1")
          (url "https://github.com/hlissner/evil-snipe"))
      (package
       (name "emacs-evil-snipe")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0rg677wdybgjqz8kfr8v7xrcqw53qm1kxcsdsqqq8z0wklb0s29d"))))
       (propagated-inputs
        (list upstream:emacs-evil))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "2-char searching ala vim-sneak & vim-seek, for evil-mode")
       (description "This library It provides 2-character motions for quickly
  (and more accurately) jumping around text, compared to evil's built-in
  f/F/t/T motions, incrementally highlighting candidate targets as you type.")
       (license license:expat))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package evil-snipe)
    (:require evil-snipe)
    (:with-function turn-off-evil-snipe-override-mode (:hook-into magit-mode))
    (:option evil-snipe-repeat-scope 'whole-line)
    (:with-mode evil-snipe-override-mode
      (:enable)))
#+end_src

**** Evil Commentary
[[https://github.com/linktohack/evil-commentary][evil-commentary]] defines operators for commenting.
#+begin_src emacs-lisp
  (setup (:package evil-commentary)
    (:also-load evil)
    (:enable))
#+end_src

**** Window map
Add my helper commands to the ~evil-window-map~
#+begin_src emacs-lisp
  (setup evil
    (:with-map evil-window-map
      (:bind "M-s"  #'my-window-shot
             "M-r"  #'my-window-record)))
#+end_src

*** God mode
[[https://github.com/emacsorphanage/god-mode][god-mode]] provides a minor mode in which modifier keys of key bindings are handled sepecially: =C-= is not needed any more, =M-= is implied with a single key, etc.
#+begin_src scheme
  (simple-service
   'home-emacs-god-mode
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-god-mode")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package god-mode)
    (:require god-mode)
    (:option god-mode-alist '((nil . "C-") ("m" . "M-") ("M" . "C-M-"))
             god-mode-enable-function-key-translation t)
    (:global
     (:with-state (normal visual motion)
       (:bind "SPC" #'god-execute-with-current-bindings))
     (:with-state (insert emacs motion)
       (:bind "C-<espace>" #'god-execute-with-current-bindings)))
    (defun my-god-mode-lookup-key-sequence (&optional key key-string-so-far)
      "Retry with literal KEY when the non-literal attempt failed."
      (interactive)
      (let ((sanitized-key
             (god-mode-sanitized-key-string
              (or key (read-event key-string-so-far)))))
        (condition-case nil
            (god-mode-lookup-command
             (god-key-string-after-consuming-key sanitized-key key-string-so-far))
          (error (when key-string-so-far
                   (setq god-literal-sequence t)
                   (god-mode-lookup-command
                    (god-key-string-after-consuming-key sanitized-key key-string-so-far)))))))

    (advice-add #'god-mode-lookup-key-sequence :override #'my-god-mode-lookup-key-sequence))
#+end_src

*** Which key
[[https://github.com/justbur/emacs-which-key][which-key]] is a minor mode that hints you the keybindings prefixed with what you have typed when you get stuck. It is built-in since Emacs 30.

I turned off ~which-key-show-transient-maps~ because it has cause ~embark-act~ on a non-minibuffer target to behave strangely when the binding in keymap is longer than a single key:
- Embark loses focus on the minibuffer (and is captured to the window containing the target)  if ~embark-prefix-help-command~ is queried after giving the first key
- ~embark-prefix-help-command~ cannot shows the correct keymap after the first key is given
#+begin_src emacs-lisp
  (setup which-key
    (:option which-key-show-transient-maps nil))
#+end_src

#+begin_src emacs-lisp
  (setup (:require which-key)
    (:option which-key-use-C-h-commands nil)
    (which-key-enable-god-mode-support)
    (:enable))
#+end_src

As a side note, which-key default configuration requires there to be at least 1 slot at the bottom in ~window-sides-slots~.
*** Posframe
[[https://github.com/tumashu/posframe][posframe]] pops a child-frame at point, connected to its root window's buffer.
#+begin_src scheme
  (simple-service
   'home-emacs-posframe
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-posframe")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package posframe))
#+end_src

*** Eldoc
#+begin_src emacs-lisp
  (setup eldoc
    (:option eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly
             (prepend display-buffer-alist) `(,(rx "*eldoc*")
                                              (display-buffer-reuse-mode-window display-buffer-in-direction)
                                              (direction . right)
                                              (window-width . fit-window-to-buffer-horiz)
                                              (body-function . select-window)
                                              (dedicated . t)
                                              (window-parameters . ((mode-line-format . none))))))
#+end_src

[[https://github.com/casouri/eldoc-box][eldoc-box]] shows eldoc in a separate childframe instead of the crowded echo area.
#+begin_src scheme
  (simple-service
   'home-emacs-eldoc-box
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-eldoc-box")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package eldoc-box)
    (:option eldoc-box-clear-with-C-g t
             eldoc-box-doc-separator
             (concat "\n"
                     (propertize " " 'face 'completions-group-separator
                                 'display '(space :align-to right)))
             eldoc-box-max-pixel-width 1600
             eldoc-box-max-pixel-height 1400)
    (:with-function eldoc-box-hover-mode
      (:hook-into text-mode prog-mode))

    (defun my-eldoc-box-quit-frame-when-interactive (interactive)
      "When manually open the doc buffer, close eldoc-box immediately."
      (when interactive
        (eldoc-box-quit-frame)))
    (advice-add #'eldoc-doc-buffer :before #'my-eldoc-box-quit-frame-when-interactive))
#+end_src

*** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] is helpful to do things the "embark" way: pick a window, then decide what to do with it.

Its package definition in the Guix official channel is for the "latest" release version, which is as old as 2014. So I makes a variation to use the master branch HEAD at the time of writing.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-ace-window-next
    (let ((commit "77115afc1b0b9f633084cf7479c767988106c196")
          (last-release-version "0.10.0")
          (revision "0"))
      (package
       (inherit upstream:emacs-ace-window)
       (name "emacs-ace-window-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/abo-abo/ace-window")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1l6rp92q4crahx9nq7s6zxqyw7ccrhkl95v70vxra7zndqpqwsbq")))))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-ace-window
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-ace-window-next")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package ace-window)
    (:also-load ace-window-posframe)
    (:option aw-keys '(?u ?h ?e ?t ?i ?d ?o ?n ?a ?s)
             aw-translate-char-function (lambda (c)
                                          (pcase c
                                            (?\[ ?7)
                                            (?\{ ?5)
                                            (?\} ?3)
                                            (?\( ?1)
                                            (?= ?9)
                                            (?* ?0)
                                            (?\) ?2)
                                            (?+ ?4)
                                            (?\] ?6)
                                            (?! ?8)
                                            (_ c)))
             aw-dispatch-alist '((?Q aw-delete-window "Delete Window")
                                 (?W aw-swap-window "Swap Windows")
                                 (?M aw-move-window "Move Window")
                                 (?C aw-copy-window "Copy Window")
                                 (?J aw-switch-buffer-in-window "Select Buffer")
                                 (?D aw-use-frame "Make frame for window")
                                 (?N aw-flip-window)
                                 (?U aw-switch-buffer-other-window "Switch Buffer Other Window")
                                 (?E aw-execute-command-other-window "Execute Command Other Window")
                                 (?F aw-split-window-fair "Split Fair Window")
                                 (?S aw-split-window-vert "Split horizontally")
                                 (?V aw-split-window-horz "Split vertically")
                                 (?O delete-other-windows "Delete Other Windows")
                                 (?T aw-transpose-frame "Transpose Frame")
                                 ;; ?i ?r ?t are used by hyperbole.el
                                 (?? aw-show-dispatch-help))))

  (setup evil
    (:global (:rebind #'evil-window-next #'ace-window
                      #'other-window  #'ace-window)))
#+end_src

=ace-window= has its =posframe= integration now (which is the main reason why I need more recent commits), which use it to show the keys in the centers of buffers.
#+begin_src emacs-lisp
  (setup ace-window-posframe
    (:when-loaded (:enable)))
#+end_src

*** Spell Checking
See the [[info:emacs#Spelling][documentation]] for details.

Emacs comes with a spell checking wrapper...
#+begin_src emacs-lisp
  (setup ispell
    (:needs "hunspell")
    (:option ispell-program-name "hunspell"))
#+end_src

... and an on-the-fly spell checker(which uses ~ispell~ as the backend).
#+begin_src emacs-lisp
  (setup flyspell
    (:needs "hunspell")
    (:unbind "C-;")
    (:hook-into text-mode)
    (:with-mode flyspell-prog-mode
      (:hook-into prog-mode)))
#+end_src

**** Flyspell Correct
The default UI for ~ispell~ is quite hard to use, and there is a package [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] that makes use of the ~completing-read~ interface to make things much more usable.

Note that the version in official Guix Package Channel is =0.6.1=, which was 3 years ago. It is kind of broken on my site, so I'll use the master HEAD version instead:
#+begin_src scheme
  (simple-service
   'home-emacs-flyspell
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("hunspell"
            "hunspell-dict-en-us"
            "emacs-flyspell-correct-next")))))
#+end_src

I drop the unused dependencies. It is ridiculous to have to propagate =ivy=, =helm= and =popup= to use this package.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-flyspell-correct-next
    (let ((commit "7d7b6b01188bd28e20a13736ac9f36c3367bd16e")
          (last-release-version "0.6.1")
          (revision "0"))
      (package
       (inherit upstream:emacs-flyspell-correct)
       (name "emacs-flyspell-correct-next")
       (arguments
        `(#:exclude '("flyspell-correct-.*\\.el")))
       (propagated-inputs (list))
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/d12frosted/flyspell-correct")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1b6h3wjmxg9d1d3mfvw6fsgkr1w0d14zxllv9jb5cscl5lq8rbmm")))))))
#+end_src

#+begin_src emacs-lisp
  (setup (:require flyspell-correct)
    (:needs "hunspell")
    (:also-load flyspell)
    (:global (:rebind #'ispell-word #'flyspell-correct-wrapper)))
#+end_src

*** Xref
=xref= is an Emacs built-in cross referencing browsing package.
#+begin_quote
This file provides a somewhat generic infrastructure for cross referencing commands, in particular "find-definition".
#+end_quote

#+begin_src emacs-lisp
  (setup xref
    (:option xref-search-program 'ripgrep)
    (:global (:with-state (normal)
               (:bind "g r" #'xref-find-references))))
#+end_src

*** Topsy
[[https://github.com/alphapapa/topsy.el][topsy]] shows a sticky header at the top of the window, displaying which function is the one that extends to the lines before the top of the displayed buffer.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-topsy
    (let ((commit "8ae0976dfdbe4461c33ed44cf1dedc2c903b0bb0")
          (last-release-version "0.1-pre") ;; from the el file version header
          (revision "0")
          (url "https://github.com/alphapapa/topsy.el"))
      (package
       (name "emacs-topsy")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "032i1prl2v5w4l37zjlqam7063s56nk61nj5l3ypmxp98yz9nrq8"))))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "Simple sticky header showing definition beyond top of window")
       (description "This library shows a sticky header at the top of the window.
  The header shows which definition the top line of the window is within. ")
       (license license:gpl3))))
#+end_src

Although =topsy= recommends to use =org-sticky-header= instead, this snippet for org-mode is good enough for me:
#+begin_src emacs-lisp
  (setup (:package topsy)
    (with-eval-after-load 'topsy
      (:option (prepend topsy-mode-functions)
               '(org-mode . (lambda ()
                              (save-excursion
                                (goto-char (window-start))
                                (when (org-at-heading-p)
                                  (forward-line -1))
                                (org-get-heading))))))
    (:hook-into prog-mode org-mode))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-topsy
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-topsy")))))
#+end_src

*** RE Builder
~re-builder~ is a built-in mode that interactively build regexp matching in a buffer.

It can build with =rx= syntax, which is super cool!
#+begin_src emacs-lisp
  (setup re-builder
    (:option reb-re-syntax 'rx))
#+end_src

Add some keybindings
#+begin_src emacs-lisp
  (setup re-builder
    (:with-mode reb-lisp-mode
      (:with-state (normal)
        (:bind "Z Q" #'reb-quit))))
#+end_src

*** Orderless
 [[https://github.com/oantolin/orderless][orderless]] add space-separated component (which then matches against several matching styles) completion style to minibuffer and other completion UI.
#+begin_src scheme
  (simple-service
   'home-emacs-orderless
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-orderless")))))
#+end_src

Orderless needs [[https://github.com/minad/consult/wiki#orderless-style-dispatchers-ensure-that-the--regexp-works-with-consult-buffer][some hack]] to work with ~consult-buffer~ and friends. Stolen from [[https://github.com/minad/consult/wiki#minads-orderless-configuration][minad's]]:
#+begin_src emacs-lisp
  (setup (:require orderless)
    (:package orderless)
    (defun +orderless--consult-suffix ()
      "Regexp which matches the end of string with Consult tofu support."
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))

    ;; Recognizes the following patterns:
    ;; * .ext (file extension)
    ;; * regexp$ (regexp matching at end)
    (defun +orderless-consult-dispatch (word _index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--consult-suffix))))
       ;; File extensions
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--consult-suffix)))))))
#+end_src

Sometimes it can be useful to use rx-notation directly.
#+begin_src emacs-lisp
  (setup orderless
    (defun my-orderless-rx (component)
      "Match a component as rx-notation."
      (when-let ((m (ignore-errors (read-from-string component)))
                 (form (car m))
                 (regex (ignore-errors (rx-to-string form)))
                 ((= (length component) (cdr m))))
        regex)))
#+end_src

For a normal orderless matching, which is triggered when ~completion-styles~ triggers orderless, it use a chain of responsibility to decide which matcher to use. Essentially, matchers are either
- grouped in dispatchers (listed in ~orderless-style-dispatchers~, each is also a chain of responsibility itself), or
- listed directly in ~orderless-matching-styles~, which is basically the catch-all dispatcher at the end of the chain.
#+begin_src emacs-lisp
  (setup orderless
    (:option orderless-style-dispatchers '(+orderless-consult-dispatch
                                           orderless-kwd-dispatch
                                           my-orderless-prefix-dispatch)
             orderless-matching-styles '(orderless-regexp)))
#+end_src

The ~my-orderless-prefix-dispatch~ is a slightly modified version of ~orderless-affix-dispatch~, which is built-in in the package. I've found that dispatching by both prefix and suffix causes more problems than the ones it attempts to solve.
#+begin_src emacs-lisp
  (setup orderless
    (defun my-orderless-prefix-dispatch (component _index _total)
      "Match COMPONENT according to the styles in `orderless-affix-dispatch-alist'.
  If the COMPONENT starts with one of the characters used
  as a key in `orderless-affix-dispatch-alist', then that character
  is removed and the remainder of the COMPONENT is matched in the
  style associated to the character."
      (let ((len (length component))
            (alist orderless-affix-dispatch-alist))
        (when (> len 0)
          (cond
           ;; Ignore single dispatcher character
           ((and (= len 1) (alist-get (aref component 0) alist)) #'ignore)
           ;; Prefix
           ((when-let ((style (alist-get (aref component 0) alist)))
              (cons style (substring component 1)))))))))
#+end_src

Affix dispatcher can be adjust by setting the ~orderless-affix-dispatch-alist~, which maps the single affix character to matcher.
#+begin_src emacs-lisp
  (setup orderless
    (:when-loaded
      (:option (prepend orderless-affix-dispatch-alist) `(?_ . ,#'my-orderless-rx)
               (prepend orderless-affix-dispatch-alist) `(?- . ,#'orderless-prefixes))))
#+end_src

Note that =file= no longer needs special treat for recent Emacs and Tramp, see [[https://github.com/minad/vertico?tab=readme-ov-file#tramp-hostname-and-username-completion][here]].

Finally, define how the completion system actually works. Minad states in the above notes that
#+begin_quote
Note that ~completion-category-overrides~ is not really an override, but rather prepended to the default ~completion-styles~.
#+end_quote

#+begin_src emacs-lisp
  (setup minibuffer
    (:option completion-category-defaults nil)
    (:option completion-styles '(orderless basic)
             completion-category-overrides '((file (styles partial-completion)))))
#+end_src

We can also defines our own completion style as used in ~completion-styles~ etc, with the help of orderless.
#+begin_src emacs-lisp
  (setup orderless
    (:when-loaded
      (orderless-define-completion-style orderless-only-initialism
        (orderless-matching-styles '(orderless-initialism)))))
#+end_src

My orderless seperator is toggle-able. It defaults to ~orderless-escapable-split-on-space~, but in cases it is possible to switch to use escaped space only. For example, it becomes handy when using ~my-orderless-rx~.
#+begin_src emacs-lisp
  (setup orderless
    (defvar my-orderless-seperator-use-escaped-space nil
      "Use escaped space in orderless component separation.")

    (defun my-orderless-seperator-toggle ()
      "Toggle the value of `my-orderless-seperator-use-escaped-space' locally"
      (interactive)
      (setq-local my-orderless-seperator-use-escaped-space
                  (not my-orderless-seperator-use-escaped-space))
      (message "use-escaped-space: [%s]" my-orderless-seperator-use-escaped-space))

    (defun my-orderless-component-separator (string)
      "Default to `orderless-escapable-split-on-space',
  but switchable to based on literal spaces."
      (if my-orderless-seperator-use-escaped-space
          (split-string string  "\\\\ " t)
        (orderless-escapable-split-on-space string)))

    (:option orderless-component-separator #'my-orderless-component-separator))
#+end_src

*** Vertico
[[https://github.com/minad/vertico][vertico]] "provides a performant and minimalistic vertical completion UI based on the default completion system."
#+begin_src scheme
  (simple-service
   'home-emacs-vertico
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-vertico")))))
#+end_src

By default, =C-b= allows the cursor to moves onto the prompt, which is not good because the prompt is read-only and many commands just don't work once you do that. On the README of vertico the author provides the following hack, utilizing ~cursor-intangible-mode~:
#+begin_src emacs-lisp
  (setup cursor-sensor
    (:option minibuffer-prompt-properties
             '(read-only t cursor-intangible t face minibuffer-prompt))
    (:with-mode cursor-intangible-mode
      (:hook-into minibuffer-setup)))
#+end_src

#+begin_src emacs-lisp
  (setup (:package vertico)
    (:require vertico)
    (:option enable-recursive-minibuffers t)
    (:with-map vertico-map
      (:rebind #'evil-goto-first-line #'vertico-first
               #'evil-goto-line #'vertico-last
               #'evil-scroll-page-down #'vertico-scroll-up
               #'evil-scroll-page-up #'vertico-scroll-down)
      (:bind "C-'" #'my-orderless-seperator-toggle))
    (:with-mode vertico-multiform-mode
      (:enable))
    (:enable))
#+end_src

*** Marginalia
[[https://github.com/minad/marginalia][marginalia]] adds info to the right of completion candidates, thus the name margin-alia.
#+begin_src scheme
  (simple-service
   'home-emacs-marginalia
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-marginalia")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package marginalia)
    (:enable))
#+end_src

*** Consult
[[https://github.com/minad/consult][consult]] provides practical commands based on the Emacs completion function =completing-read=. What this means is that basically =consult= pop up candidates when calling its commands into =comleting-read=.
#+begin_src scheme
  (simple-service
   'home-emacs-consult
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-consult")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package consult)
    (:require consult)
    (:option consult-preview-key "C-j"
             xref-show-definitions-function #'consult-xref
             xref-show-xrefs-function #'consult-xref
             consult-locate-args "plocate --ignore-case --regex")
    ;; from https://github.com/minad/consult/wiki#consult-ripgrep-or-line-counsel-grep-or-swiper-equivalent
    (defcustom my-consult-ripgrep-or-line-limit 300000
      "Buffer size threshold for `my-consult-ripgrep-or-line'.
  When the number of characters in a buffer exceeds this threshold,
  `consult-ripgrep' will be used instead of `consult-line'."
      :type 'integer)


    (defun my-consult-grep--compile-input (input)
      (pcase-let* ((split-style (alist-get consult-async-split-style
                                           consult-async-split-styles-alist))
                   (`(,first-input-and-flags ,pos . ,_)
                    (funcall (plist-get split-style :function) input split-style))
                   (first-input (car (consult--command-split first-input-and-flags)))
                   (second-input (substring input pos))
                   (compiled (mapcan (lambda (input) (car (consult--compile-regexp input 'emacs completion-ignore-case)))
                                     (list first-input second-input))))
        (consult--join-regexps compiled 'emacs)))

    (defun my-consult-line--compile-input (input)
      (consult--join-regexps (car (consult--compile-regexp input 'emacs completion-ignore-case)) 'emacs))


    (defun my-consult-line-managable-p ()
      "Which function should be used for matching lines."
      (or (not buffer-file-name)
          (buffer-narrowed-p)
          (ignore-errors
            (file-remote-p buffer-file-name))
          (jka-compr-get-compression-info buffer-file-name)
          (<= (buffer-size)
              (/ my-consult-ripgrep-or-line-limit
                 (if (eq major-mode 'org-mode) 2 1)))))

    (defun my-consult-ripgrep-or-line ()
      "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
      (interactive)
      (let* ((history-p (and (bound-and-true-p evil-mode) (eq evil-search-module 'evil-search)))
             (pattern (if (my-consult-line-managable-p)
                          (progn (consult-line)
                                 (when-let* ((_ history-p)
                                             (hist (car consult--line-history)))
                                   (my-consult-line--compile-input hist)))
                        (when (file-writable-p buffer-file-name)
                          (save-buffer))
                        (let ((consult-ripgrep-args (concat consult-ripgrep-args " --hidden")))
                          (consult-ripgrep (list buffer-file-name)))
                        (when-let* ((_ history-p)
                                    (hist (car consult--grep-history)))
                          (my-consult-grep--compile-input hist)))))
        (when pattern
          (evil-push-search-history pattern (eq evil-ex-search-direction 'forward))
          (setq evil-ex-search-pattern (list pattern t t))
          (when evil-ex-search-persistent-highlight
            (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

    (defmacro my-ignore-arg (fn)
      "Define a wrapper for an interactive function that ignores its input.
  Unlike `defun',this guarantees to return the defined function symbol."
      (let* ((fn-value (eval fn))
             (old-name (symbol-name fn-value))
             (new-name (concat "my-ignore-arg-" old-name))
             (doc (documentation fn-value)))
        `(progn (defun ,(intern new-name) ()
                  ,doc
                  (interactive)
                  (call-interactively ,fn))
                #',(intern new-name))))
    (defvar-keymap my-global-consult-map)
    (:with-map my-global-consult-map
      (:bind
       ;; "g" (my-with-universal-argument #'consult-ripgrep)
       "f" #'consult-fd
       "b" #'consult-buffer
       "l" #'consult-flymake
       "F" #'consult-locate
       "i" #'consult-imenu
       "o" #'consult-outline
       "m" #'consult-minor-mode-menu
       "x" #'consult-mode-command
       "k" #'consult-man
       "l" #'my-consult-ripgrep-or-line))

    (defmacro my-evil-ex-search- (fn direction)
      (let* ((fn-value (eval fn))
             (dirs (symbol-name (eval direction)))
             (new-name (concat "my-evil-ex-search-" dirs))
             (doc (documentation fn-value)))
        `(progn (defun ,(intern new-name) ()
                  ,doc
                  (interactive)
                  (setq evil-ex-search-direction ,direction)
                  (call-interactively ,fn))
                #',(intern new-name))))

    (:global (:rebind #'evil-ex-search-forward (my-evil-ex-search- #'my-consult-ripgrep-or-line 'forward)
                      #'evil-ex-search-backward (my-evil-ex-search- #'my-consult-ripgrep-or-line 'backward))))
#+end_src

For ~consult-grep~ families and ~consult-find~ families, it is possible to convert orderless patterns into their PCRE pattern inputs, as suggested by the [[https://github.com/minad/consult/wiki#use-orderless-as-pattern-compiler-for-consult-grepripgrepfind][Wiki]].
#+begin_src emacs-lisp
  (setup consult
    (defun consult--orderless-regexp-compiler (input type &rest _config)
      (setq input (cdr (orderless-compile input)))
      (cons
       (mapcar (lambda (r) (consult--convert-regexp r type)) input)
       (lambda (str) (orderless--highlight input t str))))

    (:option consult--regexp-compiler #'consult--orderless-regexp-compiler))
#+end_src

~consult-info~ can be used as a ~Info-search~ drop-in replacement:
#+begin_src emacs-lisp
  (setup info
    (:with-mode Info-mode
      (:rebind #'Info-search #'consult-info
               #'Info-search-case-sensitively #'consult-info)))

  (setup consult
    (defun consult-info-emacs ()
      "Search through Emacs info pages."
      (interactive)
      (consult-info "emacs" "efaq" "elisp" "eintr" "cl"))

    (defun consult-info-org ()
      "Search through the Org info page."
      (interactive)
      (consult-info "org" "orgguide" "org-roam" "org-super-agenda"))

    (defun consult-info-completion ()
      "Search through completion info pages."
      (interactive)
      (consult-info "vertico" "consult" "marginalia" "orderless" "embark"
                    "corfu" "tempel"))

    (defun consult-info-guix ()
      "Search through guix info pages."
      (interactive)
      (consult-info "guix" "guix-cookbook" "emacs-guix" "guile")))
#+end_src

*** Embark
[[https://github.com/oantolin/embark][embark]] is probably the most world-changing package in Emacs recently. It basically provides a just-in-time context-aware action list (quite like no-repeating hydra or which-key) in minibuffer on the =complete-read= candidate or on anything in the editing file.

Reference:
- [[https://github.com/oantolin/embark/wiki][wiki]]
- [[https://karthinks.com/software/fifteen-ways-to-use-embark/][15 ways to use embark]]

#+begin_src scheme
  (simple-service
   'home-emacs-embark
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-embark")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package embark)
    (:require embark)
    ;; Optionally replace the key help with a completing-read interface
    (:option prefix-help-command #'embark-prefix-help-command)
    (:option embark-cycle-key "C-z")
    (:option (remove embark-indicators)
             'embark-mixed-indicator
             (prepend embark-indicators)
             'embark-minimal-indicator)
    (:with-map minibuffer-local-map (:bind "C-z" #'embark-act))
    (:global (:bind "C-h B" #'embark-bindings) ;; alternative for `describe-bindings'
             (:with-state (normal visual)
               (:bind "g a" #'embark-act
                      "g A" #'my-embark-act-other-window)))
    ;; display embark action buffer at frame bottom
    (:option (prepend display-buffer-alist)
             `(,(rx "*Embark Actions*")
               (display-buffer-in-direction)
               (window . root)
               (direction . below)
               (window-height . fit-window-to-buffer)
               (window-parameters . ((no-other-window . t)
                                     (mode-line-format . none))))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package embark-consult)
    (:require embark-consult))
#+end_src

With ~embark-live~, a buffer is live-updating to show the candidates of the current completing-read, which means vertico's own view is redundant. Minad Provides [[https://github.com/minad/vertico/wiki#automatically-shrink-vertico-for-embark-live][the following solution]]. Note that this needs ~vertico-multiform-mode~.
#+begin_src emacs-lisp
  (setup embark
    (defun +embark-live-vertico ()
      "Shrink Vertico minibuffer when `embark-live' is active."
      (when-let (win (and (string-prefix-p "*Embark Live" (buffer-name))
                          (active-minibuffer-window)))
        (with-selected-window win
          (when (and (bound-and-true-p vertico--input)
                     (fboundp 'vertico-multiform-unobtrusive))
            (vertico-multiform-unobtrusive)))))
    (:with-mode embark-collect-mode
      (:hook +embark-live-vertico)))
#+end_src

**** Consult-based Embark Cycle
I find typing =embark-cycle-key= both slow (if there are MANY targets) and inconsistent (I need to keep an eye on what is the current target), so I come up with the following advice to make it use ~consult--read~ instead.

The way to use it is simply by typing =embark-cycle-key= as usual, or set the universal argument before doing ~embark-act~. In either case, a consult session will be brought up, and we can select targets by their types in it. Once a target is picked, the embark target list will be rotated until the selected target is at front.
#+begin_src emacs-lisp
  (setup embark-consult
    (defun my-consult-embark--target-candidate (cand)
      (let* ((type (plist-get cand :type))
             (type-string (symbol-name type))
             (target (plist-get cand :target))
             (type (propertize type-string 'consult-embark-target target)))
        (cons type cand)))

    (defun my-consult-embark--target-read (targets)
      (let* ((targets (cl-mapcar #'my-consult-embark--target-candidate targets))
             (indent (+ 2 (apply #'max (cl-mapcar (lambda (target) (length (car target))) targets))))
             (align (propertize " " 'display `(space :align-to (+ left ,indent))))
             (target (consult--read
                      targets
                      :prompt "Target: "
                      :require-match t
                      :category 'embark-target
                      :annotate (lambda (tgt)
                                  (let ((target (get-pos-property 0 'consult-embark-target tgt)))
                                    (concat align (embark--truncate-target target))))
                      :lookup #'consult--lookup-cdr)))
        target))

    (:option (prepend completion-category-overrides) '(embark-target (styles orderless-only-initialism)))

    (defun my-embark--rotate-modify-k (args)
      (pcase-let ((`(,targets ,k) args))
        (list targets
              (if-let (((cdr targets)) ;; len >= 2
                       ((plistp (car targets))) ;; is target list
                       ((not (embark--action-repeatable-p this-command))) ;; is not auto rotate after repeat
                       (target (my-consult-embark--target-read targets))
                       (step (cl-position target targets)))
                  step
                k))))
    (advice-add #'embark--rotate :filter-args #'my-embark--rotate-modify-k))
#+end_src

After using this set-up for a while, I found it quite annoying that it requires hitting =RET= after filtering to pick targets. This can be fixed with this advice:
#+begin_src emacs-lisp
  (define-advice vertico--update (:after (&rest _) choose-filtered-target)
    "Pick the target when input has filtered candidates to only one."
    (when (and (eq vertico--total 1)
               (eq (vertico--metadata-get 'category) 'embark-target)
               (> (cdr vertico--input) 0))
      (vertico-exit)))
#+end_src

**** Embark as the leader key
The original idea is from [[https://github.com/oantolin/embark/wiki/Additional-Actions#use-embark-like-a-leader-key][the wiki]].
#+begin_src emacs-lisp
  (setup embark
    (defvar my-embark-leader-target-finder '()
      "List of embark targets that are used in leader key invocation."))
#+end_src

#+begin_src emacs-lisp
  (setup embark
    (cl-defun my-embark--ignore-target (&key action target &allow-other-keys)
      "If the target is empty (introduced by global), do thing."
      (when (string-empty-p target)
        (embark--ignore-target)))

    (defun embark-target-global ()
      (cons 'global ""))

    (map-keymap
     (lambda (_key cmd)
       (cl-pushnew 'my-embark--ignore-target
                   (alist-get cmd embark-target-injection-hooks)))
     my-global-consult-map)

    (:when-loaded
      (:option (prepend my-embark-leader-target-finder) #'embark-target-global
               (prepend embark-keymap-alist) '(global . my-global-consult-map))))
#+end_src

#+begin_src emacs-lisp
  (setup embark
    (defun embark-target-this-buffer ()
      (when-let ((buffer (buffer-name)))
        (cons 'this-buffer buffer)))

    (defvar-keymap this-buffer-map
      :doc "Commands to act on current file."
      :parent embark-buffer-map
      "g" #'revert-buffer
      "u" #'vundo
      "D" #'toggle-window-dedicated)

    (:when-loaded
      (:option (prepend my-embark-leader-target-finder) #'embark-target-this-buffer
               (prepend embark-keymap-alist) '(this-buffer . this-buffer-map))))
#+end_src

#+begin_src emacs-lisp
  (setup embark
    (defun embark-target-this-file ()
      (when-let ((file (buffer-file-name)))
        (cons 'this-file file)))

    (defvar-keymap this-file-map
      :doc "Commands to act on current file."
      :parent embark-file-map
      "g" #'revert-buffer)

    (:when-loaded
      (:option (prepend my-embark-leader-target-finder) #'embark-target-this-file
               (prepend embark-keymap-alist) '(this-file . this-file-map))))
#+end_src

I realize that when using Embark as the leader key, all the targets I really want are the targets defined in this heading section.  Thus I'd rather get rid of other targets in this situation.  This is actually suggested in the wiki, but I didn't understand the implication on the overall productivity at that time.
#+begin_src emacs-lisp
  (setup embark
    (defun my-embark-leader ()
      (interactive)
      (let ((embark-target-finders `(embark--vertico-selected
                                     embark-target-top-minibuffer-candidate
                                     embark-target-collect-candidate
                                     ,@my-embark-leader-target-finder))
            (current-prefix-arg '(4)))
        (call-interactively #'embark-act))))
#+end_src

#+begin_src emacs-lisp
  (setup evil
    (:global
     (:unbind "C-SPC")
     (:bind "C-SPC" #'my-embark-leader)))
#+end_src

**** Open in chosen window
I found that very often I want the buffer opened by embark to be somewhere I assign. Adapted from [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Karthik Chikmagalur's hack]] and [[https://karthinks.com/software/emacs-window-management-almanac/#a-window-prefix-command-for-ace-window][ace-window-prefix]], I now have a way of picking the window (or splitting on-the-fly) by calling ~my-embark-act-other-window~. For minibuffer things are a little bit complicated, and currently I'm using a toggle outside of Embark directly.
#+begin_src emacs-lisp
  (setup embark
    (defun ace-window-prefix ()
      "Use `ace-window' to display the buffer of the next command.
      The next buffer is the buffer displayed by the next command invoked
      immediately after this command (ignoring reading from the minibuffer).
      Creates a new window before displaying the buffer.
      When `switch-to-buffer-obey-display-actions' is non-nil,
      `switch-to-buffer' commands are also supported."
      ;; stolen from https://karthinks.com/software/emacs-window-management-almanac/#a-window-prefix-command-for-ace-window
      (interactive)
      (display-buffer-override-next-command
       (lambda (buffer _)
         (let (window type (aw-dispatch-always t))
           (setq
            window (aw-select (propertize " ACE" 'face 'mode-line-highlight))
            type 'reuse)
           (cons window type)))
       nil "[ace-window]")
      (message "Use `ace-window' to display next command buffer..."))

    (defvar my-embark-prefix-commands '(ace-window-prefix other-window-prefix)
      "Commands that should be considered as a prefix command.")

    (defun my-embark-is-prefix-command (cmd)
      (memq cmd my-embark-prefix-commands))

    (define-advice embark-keymap-prompter (:around (orig-fun keymap update) handle-prefix-command)
      "Don't use prefix command as embark action."
      (let ((cmd (funcall orig-fun keymap update)))
        (pcase cmd
          ((pred my-embark-is-prefix-command)
           (ignore-errors (command-execute cmd))
           (embark-keymap-prompter keymap update))
          (_ cmd))))

    (:global
     (:with-state (normal visual)
       (:bind "M-o" #'ace-window-prefix)))
    (:with-map vertico-map
      (:bind "M-o" #'ace-window-prefix))
    (:with-map embark-meta-map
      (:bind "M-o" #'ace-window-prefix)))
#+end_src
Note: Somehow only post-hooks can recognize ~(minibufferp)~.

**** Keybindings for copy
As evil user, =w= is too strange for me.
#+begin_src emacs-lisp
  (setup embark
    (:with-map embark-general-map
      (:unbind "w")
      (:bind "y" #'embark-copy-as-kill))
    (:with-map embark-file-map
      (:unbind "W")
      (:bind "Y" #'embark-save-relative-path))
    (:with-map embark-package-map
      (:unbind "W")
      (:bind "Y" #'embark-save-package-url))
    (:with-map embark-unicode-name-map
      (:unbind "W")
      (:bind "Y" #'embark-save-unicode-character)))

  (setup embark-org
    (:with-map embark-org-link-copy-map
      (:unbind "w")
      (:bind "y" #'embark-org-copy-link-inner-target))
    (:with-map embark-org-link-map
      (:unbind "w")
      (:bind "y" #'embark-org-link-copy-map)))
#+end_src

**** Copy file name with line number
This is quite useful for GUD GDB etc.  The original idea is from [[https://mbork.pl/2025-04-14_Copying_the_current_location_on_steroids][Marcin Borkowski]] but I don't need something that fancy.
#+begin_src emacs-lisp
  (setup embark
    (defun my-copy-file-location (buf)
      "Copy the buffer's file name with line number."
      (interactive "bBuffer: ")
      (when-let* ((buffer (if buf buf (current-buffer)))
                  (file-name (with-current-buffer buffer buffer-file-name))
                  (line (with-current-buffer buffer
                          (line-number-at-pos nil 'absolute)))
                  (s (format "%s:%d" (file-name-nondirectory file-name) line)))
        (kill-new s)))

    (:with-map embark-buffer-map (:bind "Y" #'my-copy-file-location)))
#+end_src

*** Tempel
[[https://github.com/minad/tempel][tempel]] is a "tiny template package for Emacs", using the built-in template package Tempo's syntax. I use it instead of famous [[https://github.com/joaotavora/yasnippet][YASnippet]] because
- YASnippet seems unmaintained (update on 2024-02: it seems to be revived!)
- YASnippet expansion with wrapping (i.e. wrapping region of text into the template) seems weird
- Tempel uses syntax of built-in Tempo, which is sexp-like expressions.
- With tempel, multiple templates can be defined within a single file, while YASnippet requires single template per file.

#+begin_src scheme
  (simple-service
   'home-emacs-tempel
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("emacs-tempel"
            "emacs-eglot-tempel")))
    (configs `(("emacs/config/templates.eld" ,(local-file "../../templates.eld"))))))
#+end_src

The functions here come from tempel's README.
#+begin_src emacs-lisp
  (setup (:package tempel)
    (defun tempel-include (elt)
      (when (eq (car-safe elt) 'i)
        (if-let (template (alist-get (cadr elt) (tempel--templates)))
            (cons 'l template)
          (message "Template %s not found" (cadr elt))
          nil)))
    (with-eval-after-load 'tempel
      (:option (prepend tempel-user-elements) #'tempel-include))
    (:option tempel-path (exdg-config "templates.eld")
             (append my-mode-line-indicators) '(tempel--active "Temp "))
    (defun tempel-setup-capf ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-expand completion-at-point-functions)))
    (:with-function tempel-setup-capf
      (:hook-into conf-mode prog-mode text-mode))
    (:with-map tempel-map
      (:bind "M-a" #'tempel-beginning
             "M-e" #'tempel-end
             "M-p" #'tempel-previous
             "M-n" #'tempel-next)))
#+end_src

global templates
#+begin_src lisp-data
  fundamental-mode

  (date (format-time-string "%Y-%m-%d"))
#+end_src

**** Eglot-tempel
Tempel itself, unlike YASnippet, does not support LSP snippet expansion out of the box.
This feature is notably useful when you auto-complete a function name, in which case the argument list is the snippet.

Anyway, [[https://github.com/fejfighter/eglot-tempel][eglot-tempel]], as the name suggests, bridges eglot's snippet interface with tempel. There is also [[https://github.com/svaante/lsp-snippet][lsp-snippet]] that might worth checking later.

#+begin_src emacs-lisp
  (setup (:package eglot-tempel)
    (:hook-into eglot-server-initialized-hook))
#+end_src
*** Corfu
[[https://github.com/minad/corfu][corfu]] is a ~completion-at-point~ implementation that is much more concise than =company=.
#+begin_src scheme
  (simple-service
   'home-emacs-corfu
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-corfu")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package corfu)
    (:option corfu-preview-current nil
             corfu-quit-at-boundary nil)
    (:option tab-always-indent 'complete)
    (:with-state (insert emacs)
      (:global (:bind "<CTRL-i>" #'completion-at-point)) ;; see early-init.el
      (:with-map corfu-map (:bind "<escape>" #'corfu-reset
                                  "SPC" #'corfu-insert-separator)))
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active)
                  (bound-and-true-p vertico--input))
        (:enable)))
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
    (:require corfu)
    (:with-mode global-corfu-mode (:enable)))
#+end_src
*** Visual Undo
[[https://github.com/casouri/vundo][vundo]] is basically a less-buggy [[https://www.dr-qubit.org/undo-tree.html][undo-tree]] that supports Emacs 28's new ~undo-redo~.
#+begin_src scheme
  (simple-service
   'home-emacs-vundo
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-vundo")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package vundo)
    (:require vundo))
#+end_src

*** Hideshow
[[info:emacs#Hideshow][hideshow]] is Emacs' built-in code folding package.
#+begin_src emacs-lisp
  (setup hideshow
    (:with-mode hs-minor-mode (:hook-into prog-mode)))
#+end_src

*** Pulse
=pulse= is a built-in package that transiently highlights a region (current cursor line, for example). Its callbacks can be added to post jump hooks, so that the jumps are easier to follow.
#+begin_src emacs-lisp
  (setup pulse
    (:with-function pulse-momentary-highlight-one-line
      (:hook-into consult-after-jump-hook imenu-after-jump-hook))
    (defun my-pulse-momentary-highlight-one-line ()
      "Momentary highlight one line if the window buffer changed."
      (when-let* ((old-window (old-selected-window))
                  (_ (window-valid-p old-window))
                  (old-buffer (with-selected-window old-window (window-buffer)))
                  (new-window (selected-window))
                  (_ (window-valid-p new-window))
                  (new-buffer (with-selected-window new-window (window-buffer)))
                  (_ (not (eq old-buffer new-buffer))))
        (pulse-momentary-highlight-one-line)))
    (:with-function my-pulse-momentary-highlight-one-line
      (:hook-into window-state-change-hook)))
#+end_src

*** electric-pair-mode
=electric-pair-mode= is a built-in package that auto insert the left bracket/parentheses when we type the left one. It also skip the right bracket/parentheses if we type it. This behavior might be familiar to many IDE users.
#+begin_src emacs-lisp
  (setup elec-pair
    (:with-mode electric-pair-local-mode
      (:hook-into prog-mode minibuffer-setup)))
#+end_src

*** Aggresive Indent
[[https://github.com/Malabarba/aggressive-indent-mode][aggressize-indent-mode]] basically reindents what you have changed after every change you made.
#+begin_src scheme
  (simple-service
   'home-emacs-aggressive-indent
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-aggressive-indent")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package aggressive-indent)
    (:hook-into emacs-lisp-mode scheme-mode)
    (:option aggressive-indent-dont-indent-if '((evil-insert-state-p) (evil-replace-state-p)))
    (defun my-aggressive-indent-after-change ()
      (cond (aggressive-indent-mode
             (add-hook 'evil-normal-state-entry-hook #'aggressive-indent--process-changed-list-and-indent nil t))
            (t
             (remove-hook 'evil-normal-state-entry-hook #'aggressive-indent--process-changed-list-and-indent t))))
    (:hook #'my-aggressive-indent-after-change))
#+end_src

*** Comint
Comint is the base major mode for all kinds of interactive REPLs.
#+begin_src emacs-lisp
  (setup comint
    (:rebind #'comint-history-isearch-backward-regexp #'consult-history))
#+end_src

*** Eshell
I plan on switching to =eshell= as my main shell. Here are some references:
- [[https://howardism.org/Technical/Emacs/eshell-why.html][Why Use Eshell?]] by Howard Abrams
- [[https://web.archive.org/web/20201111230155/https://ambrevar.xyz/emacs-eshell/][Eshell as a main shell (web archived)]] by Pierre Neidhardt
- [[https://famme.sk/blog/how-about-eshell.html][BASH, ZSH, FISH. How about Eshell?]] from TRITON FAMME
- [[https://emacs-china.org/t/topic/5362][Discussion on Tweaking Eshell]]  on Emacs China (in Chinese)
- [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][Mastering Eshell]] by Mickey Petersen
- [[https://github.com/condy0919/emacs-newbie/blob/master/introduction-to-builtin-modes.md#eshell][Introductions to Emacs Builtin Mode Features]] from =emacs-newbie= (in Chinese)
- [[https://emacs.stackexchange.com/questions/75369/use-hs-minor-mode-where-its-not-supported][Use =hs-minor-mode= Where It's Not Supported]] asked on Emacs Stack Exchange
- [[https://blog.liangzan.net/blog/2012/12/12/customizing-your-emacs-eshell-prompt/][Customizing Your Emacs Eshell Prompt]] by Liang Zan
- [[https://www.emacswiki.org/emacs/CategoryEshell][Eshell Category]] on Emacs Wiki
- [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell's Offical Manual]]

#+begin_src emacs-lisp
  (setup eshell
    (:option (prepend display-buffer-alist)
             `(,(rx bos "*" (opt (1+ (or alnum "-")) "-") "eshell*")
               display-buffer-in-side-window
               (side . right)
               (slot . 0)
               (window-parameters . ((no-delete-other-windows . t)))
               (window-width . 80))))
#+end_src

Eshell by default don't bind =C-d= to quitting the shell window and process. To do this, I steal
[[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org#shell-here][a snippet from Howard Abrams]] and modified it a little bit to use the new Emacs 30 features.
#+begin_src emacs-lisp
  (setup eshell
    (defun my-eshell-quit-or-delete-char (arg)
      (interactive "p")
      (if-let* (((eolp))
                (point (save-excursion
                         (when-let* ((match (text-property-search-backward 'field 'prompt t)))
                           (goto-char (prop-match-end match)))))
                ((eq point (point-max))))
          (progn
            (insert "exit")
            (eshell-send-input))
        (delete-forward-char arg)))
    (:with-state insert (:bind "C-d" #'my-eshell-quit-or-delete-char)))
#+end_src

Use ~consult-history~ instead of ~eshell-*-matching-input~
#+begin_src emacs-lisp
  (setup eshell
    (:rebind #'eshell-previous-matching-input #'consult-history
             #'eshell-next-matching-input #'consult-history))
#+end_src

When each session ends, append session history instead of replacing the whole history:
#+begin_src emacs-lisp
  (setup eshell
    (:option eshell-history-append t))
#+end_src

**** fish-completion
[[https://gitlab.com/Ambrevar/emacs-fish-completion][fish-completion]] is a cool package that empowers Eshell with auto-completion feature from the fish shell. This package even has the ability to fallback on auto-completion provided by bash shell, although I'm not using that right now.
#+begin_src scheme
  (simple-service
   'home-emacs-fish-completion
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-bash-completion")
      (specification->package
       "emacs-fish-completion")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package fish-completion)
    (:needs "fish")
    (:option fish-completion-fallback-on-bash-p t)
    (:hook-into eshell-mode))
#+end_src

*** Ediff
#+begin_src emacs-lisp
  (setup ediff
    (:option ediff-window-setup-function #'ediff-setup-windows-plain))
#+end_src

*** Magit
[[https://github.com/magit/magit][magit]] is an Emacs interface to git, which provides not only commands to call but also a full GUI-like wrapper around git.
#+begin_src scheme
  (simple-service
   'home-emacs-magit
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-magit")))))
#+end_src

It's manual:
#+begin_src emacs-lisp
  (setup info
    (:when-loaded
      (:option (prepend Info-url-alist)
               `(("magit" "forge" "ghub"
                  "magit-section" "magit-popup"
                  "transient" "with-editor")
                 . "https://magit.vc/manual/%m/%e"))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package magit)
    (:bind "SPC" #'god-execute-with-current-bindings)
    (:with-map (magit-revision-mode-map magit-section-mode-map magit-diff-mode-map) (:bind "SPC" #'god-execute-with-current-bindings))
    (:option magit-display-buffer-function #'display-buffer
             magit-bury-buffer-function #'quit-window ;; play nice with shackle
             evil-collection-magit-use-z-for-folds t
             magit-bind-magit-project-status nil))
#+end_src

Its Evil integration is now a part of evil-collection.

*** Project
Since Emacs 28, the built-in =project.el= implements most functionalities needed for project management, which makes [[https://github.com/bbatsov/projectile][projectile]] unnecessary.
#+begin_src emacs-lisp
  (setup (:require project)
    (:option project-switch-use-entire-map t
             project-list-file (exdg-state "project-list.el"))
    (:with-map project-prefix-map
      (:bind "m" #'magit-project-status
             "v" #'my-project-vterm
             "s" #'my-project-vterm-command
             "g" (my-ignore-arg #'consult-ripgrep))))
#+end_src

#+begin_src emacs-lisp
  (setup embark
    (defun embark-target-project ()
      (cons 'project
            (if-let ((project (project-current nil))
                     (project-name (project-name project)))
                project-name
              "<unknown>")))

    (map-keymap
     (lambda (_key cmd)
       (cl-pushnew 'embark--ignore-target
                   (alist-get cmd embark-target-injection-hooks)))
     project-prefix-map)

    (:when-loaded
      (:option (prepend my-embark-leader-target-finder) #'embark-target-project
               (prepend embark-keymap-alist) '(project . project-prefix-map))))
#+end_src

~project-prefixed-buffer-name~ is used for project shells (and Eshells), we can configure it to be used for compilation buffers too:
#+begin_src emacs-lisp
  (setup project
    (:option project-compilation-buffer-name-function #'project-prefixed-buffer-name))
#+end_src

However, its implementation does not work very well with directories that shared the same name but across different computers, when accessed with TRAMP.

To fix this easily, I decide to override ~project-name~:
#+begin_src emacs-lisp
  (cl-defmethod project-name :extra "prefixed with remote identifier"
    (project)
    "Prefix the project name with remote identifier if available."
    (let* ((dir (directory-file-name (project-root project)))
           (base (file-name-nondirectory dir)))
      (if-let* ((remote (file-remote-p dir))
                (formatted (substring remote 1)))
          (concat formatted base)
        base)))
#+end_src

Emacs 30 has introduced ~uniquify-dirname-transform~ that customize how buffer names are uniquified, which gives more deterministic result if we set it to the built-in project powered variant:
#+begin_src emacs-lisp
  (setup uniquify
    (:option uniquify-dirname-transform #'project-uniquify-dirname-transform))
#+end_src

*** Emacsql
[[https://github.com/magit/emacsql][emacsql]] is "a high-level Emacs Lisp RDBMS front-end", which provides a consistent facade for different sqlite integration implementations. There is one tagged version in Guix package upstream, but it is too old for my need (and it comes with too many unnecessary dependencies), see below.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-emacsql-minimal
    (package
      (inherit upstream:emacs-emacsql)
      (name "emacs-emacsql-minimal")
      (propagated-inputs (list))
      (build-system emacs-build-system)
      (arguments
       '(#:include '("emacsql.el" "emacsql-compiler.el" "emacsql-sqlite.el" "emacsql-sqlite-common.el")))))
#+end_src

=emacsql-sqlite-builtin=, on the other hand, is the built-in integration shipped with Emacs 29.  We have to use Emacs 29 to compile it, instead of =emacs-minimal=, to makes the build phase happy.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-emacsql-sqlite-builtin
    (package
      (inherit emacs-emacsql-minimal)
      (name "emacs-emacsql-sqlite-builtin")
      (propagated-inputs (list emacs-emacsql-minimal))
      (build-system emacs-build-system)
      (arguments
       `(#:include '("emacsql-sqlite-builtin.el")))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-emacsql
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-emacsql-sqlite-builtin")))))
#+end_src

*** Epub
Emacs' built-in  [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]] is said to support Epub format, but I've never got it to work. [[https://depp.brause.cc/nov.el/][nov.el]] to the rescue.

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-nov-el-next
    (let ((commit "cc31ce0356226c3a2128119b08de6107e38fdd17")
          (last-release-version "0.4.0")
          (revision "0"))
      (package
       (inherit upstream:emacs-nov-el)
       (name "emacs-nov-el-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://depp.brause.cc/nov.el.git")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0k09dd0j8m8607dv61qm4q1jk9hvn39sxzk5ckcalafjanp7l0r6")))))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-nov-el
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-nov-el-next")))))
#+end_src

#+begin_src emacs-lisp
  (setup nov
    (:system 'gnu/linux)
    (:option nov-save-place-file (exdg-state "nov-save-place.el")
             (prepend auto-mode-alist) `(,(rx ".epub" eos) . nov-mode)))
#+end_src

*** Pdf
For PDF files, Emacs' built-in [[info:emacs#Document View][doc-view]] mode is actually quite usable. It pre-renders the PDF files into images and save them in the filesystem.

Anyway, I use [[https://github.com/vedang/pdf-tools][pdf-tools]] which relies on an external program =epdfinfo= that utilizes [[https://poppler.freedesktop.org/][poppler]]. The pages are rendered on-demand and stored in memory only, and more importantly it provides some extra features, such as the support for PDF markup annotations.
#+begin_src scheme
  (simple-service
   'home-emacs-pdf-tools
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-pdf-tools")))))
#+end_src

Its Guix package already handles the =pdfinfo= program, so I set it up without letting it re-attempt the build-on-the-fly process.
#+begin_src emacs-lisp
  (setup pdf-tools
    (:system 'gnu/linux)
    (pdf-loader-install nil t))
#+end_src

*** Org Mode
From its website
#+begin_quote
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system.
#+end_quote
this is only a facial overall summary of what [[https://orgmode.org][org-mode]] is usually used for. It is so powerful that It is one of the reasons I switched from Neovim to Emacs.

Useful References:
- [[https://alphapapa.github.io/org-almanac/][org-almanac]], an "awesome"-ish list of what people are using Org Mode for.

#+begin_src scheme
  (simple-service
   'home-emacs-org
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("emacs-org"
            "emacs-evil-org"
            "emacs-toc-org"
            ;; "emacs-org-appear-next"
            "emacs-org-download-next")))))
#+end_src

#+begin_src emacs-lisp :noweb yes
  (setup org
    <<org-setup>>
    (:hook visual-line-mode variable-pitch-mode))
#+end_src

Its manual:
#+begin_src emacs-lisp
  (setup info
    (:when-loaded
      (:option (prepend* Info-url-alist)
               '((("org") . "https://orgmode.org/manual/%e")
                 (("orgguide") . "https://orgmode.org/guide/%e")))))
#+end_src

**** General Settings
Turn on =org-indent=, aka clean view by default:
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-startup-indented t)
#+end_src

Enforce to-do dependencies (i.e. children block their parent)
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-enforce-todo-dependencies t)
#+end_src

When the cursor is on the headline, =c-a= =c-e= will stop after the leading stars and before the tags, respectively. Likewise, =c-k= will only delete up to the tags. Moreover, =evil-org= respects these settings.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-special-ctrl-a/e t)
  (:option org-special-ctrl-k t)
#+end_src

Prevent =M-RET= from splitting the line if the line is a headline or an item.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-M-RET-may-split-line '((default . nil)))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-persist-directory (exdg-cache "org-persist"))
#+end_src

Org-mode defaults to "show everything" whenever a buffer is initially opened, which includes property drawers. I think the default was "show all", which unfold most things except properties, but the default was changed upstream at some point. But anyway, "show all" is the desired behavior for me, because using =org-roam= means there are properties that I have no interest in everywhere.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-startup-folded 'showall)
#+end_src

Disable org-mode's own window arrangement when editing source block and have it just use ~display-buffer~. With this way, the window control is left to ~display-buffer-alist~.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-src-window-setup 'plain)
#+end_src

Templates:
#+begin_src lisp-data
  org-mode

  (begin "#+begin_" (s name) n r n "#+end_" name)
  (elisp "#+begin_src emacs-lisp" n r n "#+end_src" :post (org-edit-src-code))
  (scheme "#+begin_src scheme" n r n "#+end_src" :post (org-edit-src-code))
  (sh "#+begin_src sh" n r n "#+end_src" :post (org-edit-src-code))
  (id :post (org-roam-node-insert))
  (cite :post (call-interactively #'citar-insert-citation))
#+end_src

**** Task Management
I generally follow the GTD way as my task management system.

***** Tasks and Logs
Todo state keywords. The todo state is simple:
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-todo-keywords
           '((sequence "TODO(t!)" "NEXT(e!)" "WAIT(w@/@)" "|" "DONE(d@)")
             ("|" "CANCELED(c@)")
             ("|" "MEETING(m)")
             ("|" "PHONE(p)")))
#+end_src

Log into a =LOGBOOK= drawer so that things are folded when we want to read about outcome descriptions
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-log-into-drawer t)
#+end_src

When refiling, log down a timestamp:
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-log-refile t)
#+end_src

I found that usually I have something to say when I closing a task, for example a link to the reproduction note. Thus I'd like to have closing note by default.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-log-done 'note)
#+end_src

Put newer note at the top:
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-reverse-note-order t)
#+end_src

Don't open files in new window. Let the ~display-buffer-alist~ decides instead.
#+begin_src emacs-lisp
  (setup ol
    (:when-loaded
      (:option (prepend org-link-frame-setup) '(file . find-file))))
#+end_src

***** Effort Measurement and Time Cost Estimates
Org mode provides the feature to estimate effort and track time spent on a task.

First, if something somehow has a =0:00= duration, don't count it.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-clock-out-remove-zero-time-clocks t)
#+end_src

Clock out when a task is =DONE= or =CANNCELED=
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-clock-out-when-done t)
#+end_src

Sometimes, I forget to clock out before rebooting or shutting down. Org Clock provides the feature to continue the previous unfinished task when Emacs restarts, which can be handy in this case.
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-clock-persist t
           org-clock-persist-file (exdg-state "org-clock-persist.el"))
#+end_src

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (org-clock-persistence-insinuate))
#+end_src

**** Literate Programming
References:
+ [[https://orgmode.org/worg/org-contrib/babel/intro.html][Babel: Introduction]] in worg/org-contrib
+ [[https://orgmode.org/manual/Working-with-Source-Code.html#Working-with-Source-Code][Working with Source Code]] from =org-mode='s manual
+ [[https://howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]] by Howard Abrams

**** Evil Org
[[https://github.com/Somelauw/evil-org-mode][evil-org]] is org mode's evil integration. It provides not simply keybindings, but also text objects.
#+begin_src emacs-lisp
  (setup (:package evil-org)
    (:require evil-org)
    (:option (remove evil-org-key-theme) 'textobjects)
    (:also-load org evil-org-agenda)
    (:hook-into org-mode)
    (evil-org-set-key-theme)
    (evil-org-agenda-set-keys)
    (:with-map org-mode-map
      (:with-state motion (:bind "RET" #'org-open-at-point))))
#+end_src

org-log buffer, i.e. the buffer created if you set to take note when state changes, is not of a special mode other than just org-mode.  So in order to still use =ZZ= and =ZQ= to finish editing or abort editing, I decide to replace the evil commands:
#+begin_src emacs-lisp
  (setup org
    (evil-define-command my-org-evil-save-modified-and-close (file &optional bang)
      "Close and saves the log buffer, otherwise call `evil-save-modified-and-close'."
      :repeat nil
      (interactive "<f><!>")
      (if (and (local-variable-p 'org-finish-function)
  	         (fboundp org-finish-function))
          (funcall org-finish-function)
        (evil-save-modified-and-close file bang)))

    (evil-define-command my-org-evil-quit (&optional force)
      "Close and saves the log buffer, otherwise call `evil-quit'."
      :repeat nil
      (interactive "<!>")
      (if (and (local-variable-p 'org-finish-function)
  	         (fboundp org-finish-function))
          (let ((org-note-abort t)) (funcall org-finish-function))
        (evil-quit force)))

    (:rebind #'evil-save-modified-and-close #'my-org-evil-save-modified-and-close
             #'evil-quit #'my-org-evil-quit))
#+end_src

**** Toc Org
[[https://github.com/snosov1/toc-org][toc-org]] will automatically update the content of the first heading with a =:TOC:= tag in an org file to show an up-to-date TOC whenever the file is saved. Handy!
#+begin_src emacs-lisp
  (setup (:package toc-org)
    (:also-load org)
    (:hook-into org-mode))
#+end_src

**** COMMENT Org Appear
[[https://github.com/awth13/org-appear][org-appear]] is a minor mode that "toggle visibility of hidden Org mode element parts upon entering and leaving an element", and it works with Evil very well.

Its package definition in the Guix Official Channel is for the "latest" release version, which is as old as January 2022. So I makes a variation to use the master branch HEAD at the time of writing.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-org-appear-next
    (let ((commit "81eba5d7a5b74cdb1bad091d85667e836f16b997")
          (last-release-version "0.3.0")
          (revision "0"))
      (package
       (inherit upstream:emacs-org-appear)
       (name "emacs-org-appear-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/awth13/org-appear")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1jh2rdp7rx1hnsfky5di1amz8rc5jf0qlc5ykr09m5f9fpz9m9x6")))))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package org-appear)
    (:option org-appear-trigger 'manual
             org-appear-autolinks t
             org-appear-autosubmarkers t
             org-appear-autoentities t)
    (defun my-org-appear-setup ()
      (cond (org-appear-mode
             (add-hook 'evil-normal-state-exit-hook #'org-appear-manual-start nil t)
             (add-hook 'evil-normal-state-entry-hook #'org-appear-manual-stop nil t))
            (t
             (remove-hook 'evil-normal-state-exit-hook #'org-appear-manual-start t)
             (remove-hook 'evil-normal-state-entry-hook #'org-appear-manual-stop t))))
    (:hook-into org-mode)
    (:hook #'my-org-appear-setup))
#+end_src

**** Personal Knowledge Management
I believe strongly that [[https://en.wikipedia.org/wiki/Personal_information_management][PIM]] as its adjective "personal" implies, is something that varies from individuals to individuals. That is, there is no such "universal best practice" for everyone. Thus, what we really need is a highly customizable framework to build our own variation. Luckily, org mode fits into this ground.

I use a personal-hacked variation of [[https://en.wikipedia.org/wiki/Zettelkasten][Zettelkasten]].

***** Org Id
Enable tracking org heading links using globally unique UIDs. This is a must-have even without =org-roam=, because org mode won't fix the broken links when you refile/archive some subtrees to a different file.
#+begin_src emacs-lisp
  (setup org-id
    (:option org-id-track-globally t
             org-id-link-to-org-use-id 'create-if-interactive
             org-id-ts-format "%Y%m%dT%H%M%SM%3N"
             org-id-locations-file (exdg-state "org-id-locations.el")))
#+end_src

***** Custom Links
Org-mode has built-in manpage link support, but it is not on by default:
#+begin_src emacs-lisp
  (setup (:require ol-man))
#+end_src

=lfile= looks up the link by querying =plocate= database, which is a pre-indexed DB for local files.
Based on [[https://karl-voit.at/2022/02/10/lfile/][blog post]] from [[https://github.com/novoid][Karl Voit]].
#+begin_src emacs-lisp
  (setup ol
    (defun my-handle-lfile-link (opener querystring)
      ;; get a list of hits
      (let ((queryresults (split-string
                           (s-trim
                            (shell-command-to-string
                             (concat
                              "plocate --existing "
                              querystring
                              " "
                              )))
                           "\n" t)))
        ;; check length of list (number of lines)
        (cond
         ((= 0 (length queryresults))
          ;; edge case: empty query result
          (message "Sorry, no results found for query: %s" querystring))
         ((= 1 (length queryresults))
          ;; exactly one hit:
          (funcall opener (car queryresults))
          )
         (t
          ;; in any other case:
          (alert (format "Sorry, multiple results found for query: %s" querystring))
          ;; FIXXME: ask user to select among multiple hits.
          )
         )))
    (org-link-set-parameters
     "lfile"
     :follow (lambda (filename) (my-handle-lfile-link #'embark-open-externally filename))
     :help-echo "Opens the file located via \"locate\" with your default application"
     ))
#+end_src
Here [[https://org-roam.discourse.group/t/implementing-hierarchies-namespaces-in-org-roam-v2/1504][is]] [[https://org-roam.discourse.group/t/link-categorization/2486][an]] [[https://org-roam.discourse.group/t/custom-roam-style-link/39/57][attempt]] [[https://forum.zettelkasten.de/discussion/887/thinking-about-metadata][to]] [[https://forum.zettelkasten.de/discussion/573/idea-for-categorizing-theory-models-definitions-arguments-and-facts][implement]] [[https://org-roam.discourse.group/t/add-link-tags-feature/][Link]] [[https://org-roam.discourse.group/t/the-case-for-custom-link-types/][Tags]].
#+begin_src emacs-lisp
  (setup ol
    (defvar my-org-id-link-special-defs '(("related" :follow org-id-open :face org-tag
                                           :help-echo "Related to the given topic.")
                                          ("follow" :follow org-id-open :face org-tag
                                           :help-echo "Is a Follow-up of the given note.")
                                          ("under" :follow org-id-open :face org-tag
                                           :help-echo "Is a sub-topic given note.")
                                          ("translate" :follow org-id-open :face org-tag
                                           :help-echo "Is a translation of the given note.")))
    (dolist (def my-org-id-link-special-defs)
      (apply #'org-link-set-parameters def))
    (defun my-org-id-link--ctor- (type desc)
      (propertize type 'desc desc))
    (defun my-org-id-link--ctor (def)
      (let* ((type (car def))
             (rest (cdr def))
             (desc (plist-get rest :help-echo)))
        (my-org-id-link--ctor- type desc)))
    (defvar my-org-id-link--types `(,(my-org-id-link--ctor- "id" "Normal org-roam link.")
                                    ,@(cl-mapcar #'my-org-id-link--ctor my-org-id-link-special-defs)))
    (defun my-org-id-link-type-read (&optional prompt)
      (let ((align (propertize " " 'display '(space :align-to (+ left 20)))))
        (consult--read
         my-org-id-link--types
         :prompt (or prompt "Types: ")
         :annotate (lambda (target) (concat align (get-pos-property 0 'desc target)))
         :require-match t)))
    (defun my-org-link-modify-type ()
      "Modify the type of the org id link at point."
      (interactive)
      (when-let (((org-in-regexp org-link-any-re))
                 (remove (list (match-beginning 0) (match-end 0)))
                 (target (or (match-string-no-properties 2)
                             (match-string-no-properties 0)))
                 (desc (match-string-no-properties 3))
                 (type-regex (rx bol (group (+ alnum)) ":"))
                 ((string-match type-regex target))
                 (old-type (match-string-no-properties 1 target))
                 (old-type-fancy (propertize old-type 'face 'org-tag))
                 (prompt (format "Modify from %s: " old-type-fancy))
                 (type-rep (my-org-id-link-type-read prompt))
                 (target (concat type-rep (string-remove-prefix old-type target))))
        (apply #'delete-region remove)
        (org-insert-link nil target desc)))
    (:with-map embark-org-link-map
      (:bind "m" #'my-org-link-modify-type))
    (:option (prepend embark-target-injection-hooks) '(my-org-link-modify-type embark--ignore-target)))
#+end_src

***** Org Roam
[[https://www.orgroam.com/][org-roam]] basically [[https://blog.jethro.dev/posts/org_roam_v2/][does]] [[https://www.orgroam.com/manual.html#Org_002droam_0027s-Design-Principle][2 things]]:
1. Use a sqlite database to cache everything that is getting slow as notes scaling up
2. Using this database to display "backlinks" for a note, a fancy word standing for the links that point to the current note.
This means that, giving that org-roam is quite stable now, we can use the database to do [[https://github.com/org-roam/org-roam/wiki/User-contributed-Tricks][many crazy things]]!

Again the packaged version in Guix official packages is quite old, so here is the git HEAD version. I also clear up the =propagated-inputs= list a little bit, especially by adding a simple hack to remove the redundant dependency on the old =emacs-sqlite=. Similar to =emacsql-sqlite-built-in=, it requires Emacs 29 to compile.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-org-roam-next
    (let ((commit "3a91a46d13796e00dfa96c0002762927e9434a66")
          (revision "3"))
      (package
        (inherit upstream:emacs-org-roam)
        (name "emacs-org-roam-next")
        (version (git-version "2.2.2" revision commit))
        (source
         (origin
           (method git-fetch)
           (uri (git-reference
                 (url "https://github.com/hiecaq/org-roam")
                 (commit commit)))
           (file-name (git-file-name name version))
           (sha256
            (base32 "0cggdrx8i5armh10jwz9457f8bm56wyqbrb20lr3gpr629lziib1"))))
        (propagated-inputs
         (modify-inputs (package-propagated-inputs upstream:emacs-org-roam)
           (replace "emacs-emacsql" emacs-emacsql-sqlite-builtin))))))
#+end_src

And a missing gem [[https://github.com/ahmed-shariff/org-roam-ql/][org-roam-ql]], which has a query syntax and feature set similar to [[https://github.com/alphapapa/org-ql][org-ql]] (It starts as a "spin-off" from org-ql I think, see [[https://github.com/alphapapa/org-ql/issues/303][this]] and [[https://github.com/alphapapa/org-ql/issues/354][this]]). Basically it turns a s-exp query into a series of SQL queries to the org-roam database.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-org-roam-ql
    (let ((commit "8a58edaa107bafb22ff2f944ac16d84f420129a0")
          (last-release-version "0.2")
          (revision "4")
          (url "https://github.com/hiecaq/org-roam-ql"))
      (package
       (name "emacs-org-roam-ql")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "11gsh611jw044zccn0ycnx992bfx9lbsp9rs4pa8pkhj5a44rh5z"))))
       (build-system emacs-build-system)
       (propagated-inputs
        (list upstream:emacs-magit
              upstream:emacs-org-super-agenda
              upstream:emacs-s
              upstream:emacs-transient
              emacs-org-roam-next))
       (arguments
        `(#:include '("^org-roam-ql.el")
          #:tests? #false))
       (home-page url)
       (synopsis "Query language for org-roam")
       (description "This package provides an interface to easily query and display
  results from your org-roam database.")
       (license license:gpl3+))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-org-roam
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("emacs-org-roam-next"
            "emacs-org-roam-ql")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package org-roam)
    (setq org-roam-db-gc-threshold (* 256 1024 1024)) ;; the type check is buggy
    (:option org-roam-database-connector 'sqlite-builtin
             org-roam-db-location (exdg-state "org-roam.db")
             org-roam-db-update-on-save nil
             org-roam-protocol-store-links nil
             org-roam-link-auto-replace nil ;; no longer needed; cause hang
             org-roam-directory (expand-file-name "notes" (xdg-user-dir "DOCUMENTS"))
             org-roam-node-display-template (concat "${hierarchy:*} " (propertize "${tags:10}" 'face 'org-tag))
             org-roam-capture-templates '(("d" "default" plain "%?"
                                           :target (file+head  "%(format-time-string org-id-ts-format).org"
                                                               "#+title: %(titlecase--string \"${title}\" titlecase-style)\n#+date: %U\n")
                                           :unnarrowed t)))
    ;; from https://github.com/org-roam/org-roam/issues/1565
    (with-eval-after-load 'org-roam-node
      (cl-defmethod org-roam-node-hierarchy ((node org-roam-node))
        "Return the hierarchy for the node."
        (let ((title (org-roam-node-title node))
              (olp (org-roam-node-olp node))
              (level (org-roam-node-level node))
              (filetitle (org-roam-node-file-title node)))
          (concat
           (when (> level 0) (concat filetitle " > "))
           (when (> level 1) (concat (string-join olp " > ") " > "))
           title))))
    (:with-mode org-roam-db-autosync-mode (:enable))
    (:with-function org-roam-db-sync (:hook-into midnight-hook))
    (defun my-org-roam--node-file-p (node)
      "Return if node is top-level."
      (= (org-roam-node-level node) 0))

    (:with-map my-global-consult-map
      (:bind "n" #'my-org-roam-node-find))
    (:option (prepend embark-target-injection-hooks)
             '(my-org-roam-node-find my-embark--ignore-target)))

  (defun my-org-roam-node-this-file (&optional assert)
    "Return the top node of this file."
    (save-excursion
      (goto-char (point-min))
      (org-roam-node-at-point assert)))

  (defun my-org-roam-buffer-display-dedicated (node)
    "Launch NODE dedicated Org-roam buffer.
  Unlike the persistent `org-roam-buffer', the contents of this
  buffer won't be automatically changed and will be held in place.

  In interactive calls prompt to select NODE, unless called with
  `universal-argument', in which case NODE will be set to
  `my-org-roam-node-this-file'."
    (interactive
     (list (if current-prefix-arg
               (my-org-roam-node-this-file 'assert)
             (org-roam-node-read nil #'my-org-roam--node-file-p nil 'require-match))))
    (org-roam-buffer-display-dedicated node))

  (defun my-org-roam-buffer-persistent-redisplay ()
    "Recompute contents of the persistent `org-roam-buffer'.
  Has no effect when there's no `my-org-roam-node-this-file'."
    (when-let ((node (my-org-roam-node-this-file)))
      (unless (equal node org-roam-buffer-current-node)
        (setq org-roam-buffer-current-node node
              org-roam-buffer-current-directory org-roam-directory)
        (with-current-buffer (get-buffer-create org-roam-buffer)
          (org-roam-buffer-render-contents)
          (add-hook 'kill-buffer-hook #'org-roam-buffer--persistent-cleanup-h nil t)))))

  (advice-add #'org-roam-buffer-persistent-redisplay :override #'my-org-roam-buffer-persistent-redisplay)

  (cl-defun my-org-roam-backlinks-get (node &key type)
    "Return the backlinks for NODE.

   When UNIQUE is nil, show all positions where references are found.
   When UNIQUE is t, limit to unique sources."
    (let* ((sql [:select [links:source links:dest links:pos links:properties]
                         :from links
                         :inner-join nodes
                         :on (= links:dest nodes:id)
                         :where (= nodes:file $s1)
                         :and (= links:type $s2)])
           (backlinks (org-roam-db-query sql (org-roam-node-file node) type)))
      (cl-loop for backlink in backlinks
               collect (pcase-let ((`(,source-id ,dest-id ,pos ,properties) backlink))
                         (org-roam-populate
                          (org-roam-backlink-create
                           :source-node (org-roam-node-create :id source-id)
                           :target-node (org-roam-node-create :id dest-id)
                           :point pos
                           :properties properties))))))

  (cl-defun my-org-roam-backlinks-section (node &key heading type (show-backlink-p nil))
    "The backlinks section for NODE.

  When UNIQUE is nil, show all positions where references are found.
  When UNIQUE is t, limit to unique sources.

  When SHOW-BACKLINK-P is not null, only show backlinks for which
  this predicate is not nil."
    (when-let ((backlinks (seq-sort #'org-roam-backlinks-sort (my-org-roam-backlinks-get node :type type))))
      (magit-insert-section ((,intern (concat "org-roam-backlinks-" type)))
        (magit-insert-heading heading)
        (dolist (backlink backlinks)
          (when (or (null show-backlink-p)
                    (and (not (null show-backlink-p))
                         (funcall show-backlink-p backlink)))
            (org-roam-node-insert-section
             :source-node (org-roam-backlink-source-node backlink)
             :point (org-roam-backlink-point backlink)
             :properties (org-roam-backlink-properties backlink))))
        (insert ?\n))))

  (setopt org-roam-mode-sections
          '((my-org-roam-backlinks-section :type "translate" :heading "Translated to:")
            (my-org-roam-backlinks-section :type "under" :heading "Super-topic Of:")
            (my-org-roam-backlinks-section :type "follow" :heading "Followed By:")
            (my-org-roam-backlinks-section :type "id" :heading "Backlinks:")
            org-roam-reflinks-section
            (my-org-roam-backlinks-section :type "related" :heading "Related:")))


  ;; org roam buffer placement
  (setup org-roam
    (:unbind "SPC")
    (:option (prepend display-buffer-alist)
             '((derived-mode . org-roam-mode)
               (display-buffer-reuse-mode-window display-buffer-in-side-window)
               (mode . org-roam-mode) ;; unless specified it is checked with eq instead of derived-p
               (side . right)
               (slot . 0)
               (window-parameters . ((no-delete-other-windows . t)))
               (window-width . 80))))
#+end_src

Add consult source:
#+begin_src emacs-lisp
  (setup org-roam
    (defvar consult--source-org-roam
      (list :name     "Notes"
            :category 'org-roam-buffer
            :narrow   ?n
            :face     'consult-buffer
            :history  'buffer-name-history
            :state    #'consult--buffer-state
            :annotate
            (lambda (buffer)
              (with-current-buffer buffer
                (org-roam-node-file-title
                 (my-org-roam-node-this-file 'assert))))
            :items
            (lambda ()
              (consult--buffer-query :mode 'org-mode
                                     :predicate #'org-roam-buffer-p
                                     :as #'consult--buffer-pair))))
    (with-eval-after-load 'consult
      (:option (append consult-buffer-sources) consult--source-org-roam)))
#+end_src

#+begin_src emacs-lisp
  (setup (:package org-roam-ql)
    (defun my-org-roam-ql--expansion-ft (title &optional exact)
      "Expansion function that query TITLE at top level.
  ft stands for file-title."
      `(and (title ,title ,exact) (level= 0)))
    (cl-defun my-org-roam-ql--expand-related (&rest tags &key (combine :and) &allow-other-keys)
      "Expansion function for related backlinks.
  Example: (related ``Algo'' ``Hardware'')"
      `(backlink-to (or ,@(cl-mapcar (lambda (tag) `(ft ,tag t)) tags)) :type "related" :combine ,combine))
    (:when-loaded
      (org-roam-ql-defexpansion 'ft "Compare to `title' of a file node" #'my-org-roam-ql--expansion-ft)
      (org-roam-ql-defexpansion 'related "Related" #'my-org-roam-ql--expand-related)))
#+end_src

Add =org-roam-ql= support to CLOSED timestamp:
#+begin_src emacs-lisp
  (setup org-roam-ql
    (:when-loaded
      (org-roam-ql-defpred 'closed
                           "Compare `closed' of a node to arg based on comparison parsed (< or >)"
                           #'org-roam-node-closed
                           #'org-roam-ql--predicate-compare-time)

      (org-roam-ql--sort-function-for-slot "closed" #'org-roam-ql--sort-time-less)))
#+end_src

Side notes: org-roam has some issue with ~org-element--cache-sync~ that cause org-mode to hang on saving occasionally. I'm still trying to figure out why.

My ~org-roam-node-find~ implementation that is able to show my link tags in annotation. This with the recent orderless updates allows me to filter notes by tags. ~my-org-roam--node-to-tags-table~'s implementation technically should be easier and faster, but somehow =GROUP_CONCAT= does not work correctly with Emacsql.
#+begin_src emacs-lisp
  (setup org-roam
    (:require org-roam-ql)
    (defun my-org-roam--name-table ()
      "Return a table of id to a list of name and aliases."
      (let* ((nodes (org-roam-ql-nodes '(level= 0)))
             (table (make-hash-table
                     :test #'equal
                     :size (length nodes))))
        (cl-loop for node in nodes do
                 (puthash (org-roam-node-id node)
                          (cons (org-roam-node-title node) (org-roam-node-aliases node))
                          table))
        table))

    (defun my-org-roam--node-to-tags-table (name-table type prefix)
      "Return an table of id to its forward links (as list of names). PREFIX is
  put before each name. TYPE is the type of the links."
      (let* ((s-ds (org-roam-db-query '[:select [source dest] :from links :where (= type $s1)] type))
             (table (make-hash-table
                     :test #'equal)))
        (cl-loop for s-d in s-ds do
                 (puthash (car s-d)
                          (cons
                           (concat prefix (car (gethash (cadr s-d) name-table)))
                           (gethash (car s-d) table nil))
                          table))
        table))

    (defun my-org-roam-node-find ()
      "Find top-level nodes."
      (interactive)
      (let* ((name-table (my-org-roam--name-table))
             (related-table (my-org-roam--node-to-tags-table name-table "related" "#"))
             (under-table (my-org-roam--node-to-tags-table name-table "under" "@"))
             (nodes (let ((nodes-temp nil))
                      (maphash (lambda (id names)
                                 (mapc (lambda (name)
                                         (push
                                          (cons (propertize (string-truncate-left name 140) 'node-id id) id)
                                          nodes-temp))
                                       names))
                               name-table)
                      nodes-temp))
             (indent (apply #'max (cl-mapcar (lambda (node) (length (car node))) nodes)))
             (align (propertize " " 'display `(space :align-to (+ left ,indent))))
             (annotate (lambda (node)
                         (let* ((id (get-pos-property 0 'node-id node))
                                (related (string-join (gethash id related-table)))
                                (under (string-join (gethash id under-table))))
                           (concat align under related))))
             (found (consult--read
                     nodes
                     :prompt "Org-Roam: "
                     :require-match nil
                     :category 'org-roam-node
                     :annotate annotate
                     :lookup (lambda (selected &rest rest)
                               (if-let (found (apply #'consult--lookup-cdr selected rest))
                                   (cons 'found found)
                                 (cons 'new selected))))))
        (if (eq 'found (car found))
            (org-roam-id-open (cdr found) nil)
          (org-roam-capture-
           :node (org-roam-node-create :title (cdr found))
           :templates nil
           :props '(:finalize find-file))))))
#+end_src

A helper function that make org-roam links by matching title:
#+begin_src emacs-lisp
  (setup org-roam
    (defun my-roam-link-make-string (desc type)
      (let* ((node (car (org-roam-ql-nodes `(ft ,desc))))
             (id (org-roam-node-id node)))
        (org-link-make-string
         (concat type ":" id)
         desc))))
#+end_src

****** org-roam-dailies
=org-roam-dailies= is =org-roam='s lightweight implementation of a subset of features from [[https://github.com/bastibe/org-journal][org-journal]]. I plan on building on top of this with some elisp code to fit into my need.

#+begin_src emacs-lisp
  (setup org-roam-dailies
    (defun my-org-roam-dailies-date (time)
      (format-time-string "%F"
                          (time-add (encode-time (parse-time-string time))
                                    (- midnight-delay))))
    (defun my-org-roam-dailies-timestamp (date offset-sec)
      (format-time-string "%FT%T"
                          (time-add (date-to-time date) (+ midnight-delay offset-sec))))
    (defvar my-org-roam-dailies-prelude
      (string-join
       '("#+title: %(my-org-roam-dailies-date \"%<%FT%T>\")"
         "#+date: %U"
         ""
         "- under %(my-roam-link-make-string \"Daily Notes\" \"under\")"
         ""
         "* Log"
         ""
         "* Done"
         "#+begin: org-roam-ql :query (and (todo \"DONE\") (closed > \"%(my-org-roam-dailies-timestamp \"%<%F>\" 0)\") (closed < \"%(my-org-roam-dailies-timestamp \"%<%F>\" (* 60 60 24))\")) :columns (file-title title closed) :sort \"closed\""
         "#+end:"
         ""
         "* Modified Notes"
         "#+begin: org-roam-ql :query (and (level= 0) (file-mtime > \"%(my-org-roam-dailies-timestamp \"%<%F>\" 0)\") (file-mtime < \"%(my-org-roam-dailies-timestamp \"%<%F>\" (* 60 60 24))\") (not (function (lambda () (list (my-org-roam-node-this-file)))))) :columns (file-title) :sort \"file-mtime\""
         "#+end:"
         "")
       "\n")
      "Prelude text at the beginning of my daily notes.")
    (:option org-roam-dailies-capture-templates
             `(("d" "default" entry
                "* %?"
                :target (file+head "%(my-org-roam-dailies-date \"%<%FT%T>\").org"
                                   ,my-org-roam-dailies-prelude))
               ("l" "log" item
                "- %U %?"
                :target (file+head+olp "%(my-org-roam-dailies-date \"%<%FT%T>\").org"
                                       ,my-org-roam-dailies-prelude
                                       ("Log")))
               ("L" "log with context" item
                "- %U at %a %?"
                :target (file+head+olp "%(my-org-roam-dailies-date \"%<%FT%T>\").org"
                                       ,my-org-roam-dailies-prelude
                                       ("Log")))))
    (defun my-org-roam-dailies-log-today ()
      (interactive)
      (org-roam-dailies-capture-today nil "l"))

    (defun my-org-roam-dailies-log-today-with-context ()
      (interactive)
      (org-roam-dailies-capture-today nil "L"))

    (defun my-org-roam-dailies-goto-date (&optional prefer-future)
      "Find the daily-note for a date using the calendar, creating it if necessary.
  Prefer past dates, unless PREFER-FUTURE is non-nil."
      (interactive "p")
      (org-roam-dailies-goto-date prefer-future "d"))

    (:with-function (my-org-roam-dailies-capture-today
                     my-org-roam-dailies-log-today
                     my-org-roam-dailies-log-today-with-context
                     my-org-roam-dailies-goto-date)
      (:autoload-this)))

  (setup embark
    (:with-map my-global-consult-map
      (:bind "l" #'my-org-roam-dailies-log-today
             "L" #'my-org-roam-dailies-log-today-with-context
             "D" #'my-org-roam-dailies-goto-date))

    (cl-pushnew 'my-embark--ignore-target
                (alist-get #'my-org-roam-dailies-goto-date embark-target-injection-hooks)))
#+end_src

***** Bibliography
#+begin_src emacs-lisp
  (defvar my-global-bibliography
    (list (expand-file-name "notes/refs.bib" (xdg-user-dir "DOCUMENTS")))
    "A list to global bib files.")
#+end_src

****** ebib
[[https://github.com/joostkremers/ebib][Ebib]] is technically not related to org-mode in most aspects. It is a front-end to BibTeX/BibLaTeX files.
#+begin_src scheme
  (simple-service
   'home-emacs-ebib
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-ebib-minimal")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-ebib-minimal
    (package
      (inherit upstream:emacs-ebib)
      (name "emacs-ebib-minimal")
      (propagated-inputs
       (modify-inputs (package-propagated-inputs upstream:emacs-ebib)
                      (delete "emacs-ivy")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package ebib)
    (:option ebib-bibtex-dialect 'biblatex
             ebib-preload-bib-files my-global-bibliography
             ebib-use-timestamp t
             ebib-file-search-dirs (list (expand-file-name "resources" (xdg-user-dir "DOCUMENTS")))
             ;; (remove ebib-hidden-fields) "isbn"
             ebib-layout 'index-only))

  (defun my--ebib-overwrite-current-entry-field-value (field value)
    (when value
      (ebib-set-field-value field value
                            (ebib--get-key-at-point)
                            ebib--cur-db 'overwrite nil)
      (ebib--set-modified t ebib--cur-db)
      (ebib--update-entry-buffer-keep-note)))

  (defun my-fetch-ebook-metadata-by-isbn (isbn)
    "This requires calibre's `fetch-ebook-metadata' in path to work."
    (interactive "s")
    (require 'dom)
    (let* ((opf (with-temp-buffer
                  (call-process "fetch-ebook-metadata" nil '(t nil) nil "-i" isbn "-o")
                  (delete-matching-lines (rx "Using proxies:" whitespace) (point-min) (point-max))
                  (libxml-parse-xml-region (point-min) (point-max))))
           (title (dom-text (dom-by-tag opf 'title)))
           (author (dom-text (dom-by-tag opf 'creator)))
           (date (dom-text (dom-by-tag opf 'date)))
           (publisher (dom-text (dom-by-tag opf 'publisher)))
           (isbn (dom-text
                  (cl-find-if
                   (lambda (node) (string= (dom-attr node 'scheme) "ISBN"))
                   (dom-by-tag opf 'identifier)))))
      (my--ebib-overwrite-current-entry-field-value "title" title)
      (my--ebib-overwrite-current-entry-field-value "date" date)
      (my--ebib-overwrite-current-entry-field-value "author" author)
      (my--ebib-overwrite-current-entry-field-value "publisher" publisher)
      (my--ebib-overwrite-current-entry-field-value "isbn" isbn)))
#+end_src
****** citar
There are quite a lot bibliographic packages, among which I use [[https://github.com/emacs-citar/citar][citar]].
#+begin_src scheme
  (simple-service
   'home-emacs-citar
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("emacs-citar-next"
            "emacs-citar-org-roam-next")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-citar-next
    (let ((commit "885b86f6733fd70f42c32dd7791d3447f93db990")
          (last-release-version "1.4.0")
          (revision "0"))
      (package
        (inherit upstream:emacs-citar)
        (name "emacs-citar-next")
        (version (git-version last-release-version revision commit))
        (source
         (origin
           (method git-fetch)
           (uri (git-reference
                 (url "https://github.com/emacs-citar/citar")
                 (commit commit)))
           (file-name (git-file-name name version))
           (sha256
            (base32
             "1kzwllhcn77z6gsdxl6r1csv9nj64qbgznpy8r8kvnri3fl55w4h")))))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package citar)
    (:option
     citar-library-paths `(,(expand-file-name "resources" (xdg-user-dir "DOCUMENTS")))
     org-cite-global-bibliography my-global-bibliography
     org-cite-insert-processor 'citar
     org-cite-follow-processor 'citar
     org-cite-activate-processor 'citar
     citar-bibliography my-global-bibliography))
#+end_src

It comes with =embark= integration, where ~citar-embark-mode~ is a global mode that introduce the target and actions, and ~citar-at-point-function~ (the callback called by =org-cite= in ~org-open-at-point~) can also be set to use =embark=. As I understand it, it is meaningless to set ~citar-at-point-function~ this way without turning on ~citar-embark-mode~, since all embark can do is to provides actions to recognized targets.
#+begin_src emacs-lisp
  (setup (:package citar-embark)
    (:option citar-at-point-function #'embark-act)
    (:enable))
#+end_src

=citar= comes with its own =org-roam= integration as a [[https://github.com/emacs-citar/citar-org-roam][separate package]]:
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-citar-org-roam-next
    (package
      (inherit upstream:emacs-citar-org-roam)
      (name "emacs-citar-org-roam-next")
      (propagated-inputs (list emacs-org-roam-next emacs-citar-next))))
#+end_src

As far as I can tell, ~citar-org-roam-mode~ automatically sets up  ~citar-notes-sources~, making the related configuration unnecessary.
#+begin_src emacs-lisp
  (setup (:package citar-org-roam)
    (:option citar-org-roam-note-title-template "${author editor}: ${title}")
    (defun my-citar-org-roam--create-capture-note (citekey entry)
      "Open or create org-roam node for CITEKEY and ENTRY."
      ;; adapted from https://jethrokuan.github.io/org-roam-guide/#orgc48eb0d
      (let ((title (citar-format--entry
                    citar-org-roam-note-title-template entry)))
        (org-roam-capture-
         :templates
         '(("r" "reference" plain "%?" :if-new
            (file+head
             "%(format-time-string org-id-ts-format).org"
             "#+title: ${title}\n#+date: %U\n")
            :immediate-finish t
            :unnarrowed t))
         :info (list :citekey citekey)
         :node (org-roam-node-create :title title)
         :props '(:finalize find-file))
        (org-roam-ref-add (concat "@" citekey))))
    (:enable)
    (advice-add #'citar-org-roam--create-capture-note :override #'my-citar-org-roam--create-capture-note))
#+end_src

One great feature of =citar-org-roam= is that [[https://github.com/org-roam/org-roam/issues/2207][we can have multiple notes per reference key]]. This makes it possible to split very long literature notes for textbooks into separate files (or just headings), per chapter for example.

***** Org Download
[[https://github.com/abo-abo/org-download][org-download]], despite its name, is an all-in-one image insertion solution for org-mode. It saves the image, no matter where it is from, online or in clipboard, and then inserts the link into org-mode.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-org-download-next
    (let ((commit "19e166f0a8c539b4144cfbc614309d47a9b2a9b7")
          (last-release-version "0.1.0")
          (revision "0"))
      (package
       (inherit upstream:emacs-org-download)
       (name "emacs-org-download-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/abo-abo/org-download")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0a2nw2vf9j335yz40x10q0vmnhxkn9frrm82apvjqsl5p7igvzvs")))))))
#+end_src

I mainly use it to keep images referenced in org-roam notes. There is no other place where I need referencing images anyway!
#+begin_src emacs-lisp
  (setup org-download
    (:option org-download-backend "wget \"%s\" -O \"%s\""
             org-download-image-dir (expand-file-name "images" org-roam-directory)
             org-yank-image-save-method (expand-file-name "images" org-roam-directory)
             org-download-method 'directory
             org-download-heading-lvl nil
             org-download-screenshot-method "maim -s %s"))
#+end_src

**** Style and Faces
This part of code is basically grabbed from [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][Beautifying Org Mode in Emacs]] by zzamboni.

Hide ===, =~= and other emphasis markers, and fontify src block natively:
#+begin_src emacs-lisp :tangle no :noweb-ref org-setup
  (:option org-hide-emphasis-markers t
           org-use-sub-superscripts '{}
           org-src-fontify-natively t
           org-tags-column 0)
#+end_src

*** English
**** Linting
#+begin_src scheme
  (simple-service
   'home-emacs-flymake-vale
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-flymake-vale")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-flymake-vale
    (let ((commit "914f30177dec0310d1ecab1fb798f2b70a018f24")
          (last-release-version "0.0.1")
          (revision "0")
          (url "https://github.com/tpeacock19/flymake-vale"))
      (package
       (name "emacs-flymake-vale")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url (string-append url ".git"))
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1fi5z1fq9lq0z74v6w70pflh2d9wjfzl5km5jpsgv065y4b3rj3j"))))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "Flymake support for Vale")
       (description "Vale is a natural language linter.
  So with flymake-vale you get on-the-fly natural language linting.")
       (license license:gpl3+)
       (propagated-inputs (list upstream:vale)))))
#+end_src

#+begin_src emacs-lisp
  (setup flymake-vale
    (:system 'gnu/linux)
    (:with-function flymake-vale-load
      (:hook-into text-mode)))
#+end_src

**** Capitalizing
[[https://github.com/duckwork/titlecase.el][titlecase]] solves one of the hardest problem in (English) writing: capitalizing titles. its most impressing feature is that it supports many standard styles, like [[https://www.chicagomanualofstyle.org/book/ed17/part2/ch08/toc.html][Chicago]] and [[https://blog.apastyle.org/apastyle/capitalization/][APA]]. I mainly use it with embark.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-titlecase
    (let ((commit "eb8d23925fb8ccbd3b2e3804fb0a312ee227610b")
          (last-release-version "0.4.1") ;; from the tags in git repo; .el's version is incorrect
          (revision "0")
          (url "https://codeberg.org/acdw/titlecase.el"))
      (package
       (name "emacs-titlecase")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url (string-append url ".git"))
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1j696incblnqhz7yi8xmshiz2p5kp910288j513sj8rknlykpr4n"))))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "Titlecase Things in Emacs")
       (description "This library only does it in English, and even then, it's pretty jankily put-together.
  Titlecase is the best-effort attempt at capitalizing titles, in English, in Emacs.")
       (license license:gpl3))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-titlecase
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-titlecase")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package titlecase)
    (:require titlecase)
    (:also-load embark)
    (:with-map embark-heading-map
      (:bind "T" #'titlecase-line))
    (:with-map embark-region-map
      (:bind "T" #'titlecase-region)))
#+end_src

**** Dictionary
#+begin_src scheme
  (simple-service
   'home-emacs-sdcv
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package "emacs-quick-sdcv")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-quick-sdcv
    (package
      (name "emacs-quick-sdcv")
      (version "1.0.1")
      (source (origin
                (method git-fetch)
                (uri (git-reference
                      (url "https://github.com/jamescherti/quick-sdcv.el")
                      (commit version)))
                (file-name (git-file-name name version))
                (sha256
                 (base32
                  "19ywfnf5ws40h9iv03xibjfk1hfpnb67zf9702px3yg5j1mhr845"))))
      (build-system emacs-build-system)
      (inputs
       (list (@(gnu packages dictionaries) sdcv)))
      (arguments
       `(#:tests? #f
         #:phases
         (modify-phases %standard-phases
           (add-after 'unpack 'set-sdcv-path
             (lambda* (#:key inputs outputs #:allow-other-keys)
               (emacs-substitute-variables "quick-sdcv.el"
                 ("quick-sdcv-program"
                  (string-append (assoc-ref inputs "sdcv")
                                 "/bin/sdcv"))))))))
      (synopsis "front-end to sdcv")
      (description "Emacs offline dictionary using the 'sdcv'.")
      (home-page "https://github.com/jamescherti/quick-sdcv.el")
      (license license:gpl3+)))
#+end_src

#+begin_src emacs-lisp
  (setup quick-sdcv
    (:option quick-sdcv-dictionary-data-dir (expand-file-name "dictionaries" (xdg-user-dir "DOCUMENTS"))
             quick-sdcv-only-data-dir t))

  (setup embark
    (:with-map embark-region-map
      (:bind "k" #'quick-sdcv-search-input)))
#+end_src

*** Eglot
Eglot is Emacs' built-in LSP client.
#+begin_src emacs-lisp
  (setup eglot
    (with-eval-after-load 'eglot
      (set-face-attribute 'eglot-highlight-symbol-face nil :inherit 'highlight)))
#+end_src

*** Haskell
#+begin_src scheme
  (simple-service
   'home-emacs-haskell
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-haskell-mode")))))
#+end_src

*** Rust
#+begin_src scheme
  (simple-service
   'home-emacs-rust
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-eglot")
      (specification->package
       "emacs-rustic-minimal")))))
#+end_src

Its package definition introduces =lsp-mode= and =flycheck=, so I defines a variant to drop them.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-rustic-minimal
    (package
      (inherit upstream:emacs-rustic)
      (name "emacs-rustic-minimal")
      (propagated-inputs
       (modify-inputs (package-propagated-inputs upstream:emacs-rustic)
         (delete "emacs-lsp-mode" "emacs-flycheck")))
      (arguments
       `(#:exclude (cons "rustic-flycheck\\.el" %default-exclude)
         ,@(substitute-keyword-arguments (package-arguments upstream:emacs-rustic))))))

#+end_src

#+begin_src emacs-lisp
  (setup (:package rustic)
    (:require rustic)
    (:option rustic-lsp-client 'eglot)
    (:option (prepend display-buffer-alist)
             '((derived-mode . rustic-compilation-mode)
               (display-buffer-reuse-mode-window display-buffer-in-side-window)
               (side . right)
               (slot . 0)
               (window-width . 80)))
    (defun my-rustic-fix-colors ()
      (kill-local-variable 'compilation-message-face)
      (kill-local-variable 'compilation-error-face)
      (kill-local-variable 'compilation-warning-face)
      (kill-local-variable 'compilation-info-face)
      (kill-local-variable 'compilation-column-face)
      (kill-local-variable 'compilation-line-face)
      (kill-local-variable 'xterm-color-names-bright)
      (kill-local-variable 'xterm-color-names))
    (:with-function my-rustic-fix-colors
      (:hook-into rustic-compilation-mode-hook rustic-cargo-spellcheck-mode-hook)))
#+end_src

*** Dhall
#+begin_src scheme
  (simple-service
   'home-emacs-dhall
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("dhall"
            "emacs-dhall-mode-next")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-dhall-mode-next
    (let ((commit "87ab69fe765d87b3bb1604a306a8c44d6887681d")
          (last-release-version "0.1.3")
          (revision "0"))
      (package
       (inherit upstream:emacs-dhall-mode)
       (name "emacs-dhall-mode-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/psibi/dhall-mode")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1h55bcn0csy7xacl6lqhr3vfva208rszjn15gsfq0pbwhx4n6zhx")))))))
#+end_src

*** Ron
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-ron-mode
    (let ((commit "c5e0454b9916d6b73adc15dab8abbb0b0a68ea22")
          (last-release-version "1.0.0") ;; from the .el's version
          (revision "0")
          (url "https://codeberg.org/Hutzdog/ron-mode"))
      (package
       (name "emacs-ron-mode")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url (string-append url ".git"))
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "132r5346m3li5n7v7fyzyg8sg3679apl7q4y57n5aq395s0q9wyn"))))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "Ron-mode for Emacs")
       (description "Syntax highlighting for Rusty Object Notation (RON).")
       (license license:expat))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-ron
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-ron-mode")))))
#+end_src

*** Dart
#+begin_src scheme
  (simple-service
   'home-emacs-dart
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-dart-mode-minimal")))))
#+end_src

It's weird that it introduces many unnecessary propagated inputs, so I make a variant to drop them.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-dart-mode-minimal
    (package
      (inherit upstream:emacs-dart-mode)
      (name "emacs-dart-mode-minimal")
      (propagated-inputs (list))))
#+end_src

*** PlantUML
#+begin_src scheme
  (simple-service
   'home-emacs-plantuml
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-plantuml-mode")))))
#+end_src

#+begin_src emacs-lisp
  (setup ob-plantuml
    (:require plantuml-mode)
    (:option org-plantuml-jar-path plantuml-jar-path
             org-plantuml-executable-path plantuml-executable-path
             org-plantuml-exec-mode 'plantuml)
    (with-eval-after-load 'org
      (:option (prepend org-src-lang-modes) '("plantuml" . plantuml))))
#+end_src

*** YAML
YAML is a configuration language that mainly uses =-= and indentations.
#+begin_src scheme
  (simple-service
   'home-emacs-yaml-mode
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-yaml-mode")))))
#+end_src

*** Vimrc
Sometimes, I want to edit vimrc-like configurations.  There is [[https://github.com/mcandre/vimrc-mode][vimrc-mode]] for that.
#+begin_src scheme
  (simple-service
   'home-emacs-vimrc-mode
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-vimrc-mode")))))
#+end_src

*** Go
#+begin_src scheme
  (simple-service
   'home-emacs-go-mode
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-go-mode")))))
#+end_src

*** Email
**** mu4e
#+begin_src scheme
  (service
   (service-type
    (name 'home-mu)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "isync")
               (specification->package
                "rss2email")
               (specification->package
                "msmtp"))))
      (service-extension
       home-emacs-service-type
       (const (home-emacs-extension
               (packages
                (list
                 (specification->package
                  "mu"))))))
      (service-extension
       home-environment-variables-service-type
       (const '(("XAPIAN_CJK_NGRAM" . "1"))))))
    (default-value #f)
    (description #f)))
#+end_src

It's manual is
#+begin_src emacs-lisp
  (setup info
    (:when-loaded
      (:option (prepend Info-url-alist)
               '(("mu4e") . "https://www.djcbsoftware.nl/code/mu/mu4e/%e"))))
#+end_src

***** Back-end Initialization
Here is How =mu= is initialized. This needs to be run manually.
#+begin_src sh :noweb yes
  mu init --maildir=<<mu-maildir()>> '--my-address=/<<mu-my-address()>>/'
#+end_src

#+name: mu-maildir
#+begin_src elisp :exports none
  (expand-file-name "mails" (xdg-user-dir "DOCUMENTS"))
#+end_src

#+name: mu-my-address
#+begin_src elisp :exports none
  (rxt-elisp-to-pcre (rx (: (+ (any alnum ".")) "@" "hiecaq" "." "org")))
#+end_src

***** Front-end Settings
#+begin_src emacs-lisp
  (setup mu4e
    (:system 'gnu/linux)
    (defun my-mu4e-trash-folder-dispatch (msg)
      (if (and msg
               (string= "/feed" (mu4e-message-field msg :maildir)))
          "/trash-feed"
        "/trash"))
    (:option mu4e-sent-messages-behavior 'delete
             mu4e-headers-auto-update nil
             mu4e-trash-folder #'my-mu4e-trash-folder-dispatch
             mu4e-headers-fields '((:human-date . 12)
                                   (:flags . 6)
                                   (:mailing-list . 10)
                                   (:from-or-to . 22)
                                   (:thread-subject))
             mu4e-thread-fold-unread t
             message-kill-buffer-on-exit t
             mail-user-agent 'mu4e-user-agent
             read-mail-command 'mu4e
             mu4e-compose-dont-reply-to-self t
             mu4e-compose-format-flowed t
             mu4e-search-include-related t
             mu4e-change-filenames-when-moving t
             user-mail-address "this@hiecaq.org"
             user-full-name "hiecaq"
             send-mail-function #'sendmail-send-it
             sendmail-program (executable-find "msmtp")
             message-send-mail-function 'message-send-mail-with-sendmail
             mail-envelope-from 'header)
    (:with-map mu4e-headers-mode-map
      (:with-state (normal)
        (:bind "T" #'mu4e-view-mark-thread))))
#+end_src
*** MPV
[[https://github.com/kljohann/mpv.el][mpv.el]] controls [[https://mpv.io/][mpv]] via its IPC interface, useful for note-taking.

#+begin_src scheme
  (simple-service
   'home-emacs-mpv
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-mpv")))))
#+end_src

Advice ~org-timer-item~ so that when mpv is running it inserts the mpv timestamp, instead of starting a new timer. This is a different approach than ~mpv-insert-playback-position~ (but it is based on its implementation), because I think this way gives better compatibility (e.g ~evil-org-open-below~)
#+begin_src emacs-lisp
  (setup org
    (org-link-set-parameters "mpv"
                             :follow (lambda (file)
                                       (if (mpv--url-p file)
                                           (mpv-play-url file)
                                         (mpv-play file))))
    (define-advice org-timer-item (:around (orig-fun &rest r) insert-mpv-timestamp)
      "Insert mpv timestamp instead if mpv is running."
      (if-let* (((mpv-live-p))
                (time (mpv-get-playback-position))
                (hms (org-timer-secs-to-hms (round time))))
          (cl-letf (((symbol-function 'org-timer)
                     (lambda (&optional _restart no-insert)
                       (funcall
                        (if no-insert #'identity #'insert)
                        (concat hms " ")))))
            (apply orig-fun r))
        (apply orig-fun r))))
#+end_src

Add ~mpv-seek-to-position-at-point~ to ~org-open-at-point-functions~ on demand:
#+begin_src emacs-lisp
  (setup mpv
    (:system 'gnu/linux)
    (:with-hook mpv-on-start-hook
      (:hook (lambda (&rest r) (add-hook 'org-open-at-point-functions
                                         #'mpv-seek-to-position-at-point))))
    (:with-hook mpv-on-exit-hook
      (:hook (lambda () (remove-hook 'org-open-at-point-functions
                                     #'mpv-seek-to-position-at-point)))))
#+end_src


Define an embark target and keymap, which can be used when mpv is running.
#+begin_src emacs-lisp
  (setup embark
    (defun embark-target-mpv ()
      (when (and (fboundp #'mpv-live-p) (mpv-live-p))
        (cons 'mpv (mpv-get-property "filename/no-ext"))))

    (defvar-keymap embark-mpv-map
      :doc "Commands to act on current mpv process."
      :parent embark-general-map
      "RET" #'mpv-pause
      "q" #'mpv-quit
      "k" #'mpv-kill
      "f" #'mpv-seek-forward
      "b" #'mpv-seek-backward
      "-" #'mpv-volume-decrease
      "+" #'mpv-volume-increase)

    (:when-loaded
      (:option (prepend embark-keymap-alist) '(mpv . embark-mpv-map)
               (prepend my-embark-leader-target-finder) #'embark-target-mpv
               (prepend* embark-repeat-actions)
               '(mpv-seek-forward
                 mpv-seek-backward
                 mpv-volume-decrease
                 mpv-volume-increase))))
#+end_src

~browse-url~ can dispatch certain matched urls to MPV directly:
#+begin_src emacs-lisp
  (setup browse-url
    (defun browse-url-mpv (url &rest args)
      (mpv-play-url url))

    (:when-loaded
      (:option (prepend browse-url-handlers)
               `(,(rx (or (seq "." (or "mkv" "mp4" "webm") eos)
                          (seq
                           bos
                           (or (seq "https://" (or "www" "m" "live") ".bilibili.com/video/")
                               "https://youtu.be/"
                               (seq "https://" (or "www" "m") ".youtube.com/" (or "watch" "embed"))))))
                 . browse-url-mpv))))
#+end_src

*** PYIM
[[https://github.com/tumashu/pyim][pyim]] is an Emacs input method framework for Chinese, similar to fcitx for Linux, which also provides some Chinese-related parsing utilities.

#+begin_src scheme
  (simple-service
   'home-emacs-pyim
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (map specification->package
          '("emacs-pyim"
            "emacs-pyim-basedict")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package pyim)
    (:require pyim)
    (:require pyim-basedict)
    (pyim-basedict-enable)
    (:option default-input-method "pyim"
             pyim-dcache-directory (exdg-cache "pyim/")
             pyim-page-length 5
             pyim-default-scheme 'quanpin))
#+end_src

PYIM use 1-based index, which is not very friendly to Dvorak-programmer keymaps. There is no configuration available currently, so  I override  ~pyim-page-menu-create~ with a slightly modified version of it.
#+begin_src emacs-lisp
  (setup pyim
    (define-advice pyim-page-menu-create
        (:override (candidates position &optional separator hightlight-current)
                my-0-base)
      "Overwrite the target to use 0-based index."
      (let ((i 0) result)
        (dolist (candidate candidates)
          (let ((str (substring-no-properties
                      (if (consp candidate)
                          (concat (car candidate) (cdr candidate))
                        candidate))))
            ;; highlight for `pyim-page-next-word'
            (push
             (if (and hightlight-current
                      (= i position))
                 (format "%d%s" i
                         (propertize
                          (format "[%s]" str)
                          'face 'pyim-page-selection))
               (format "%d.%s " i str))
             result)
            (setq i (1+ i))))
        (string-join (nreverse result) (or separator "")))))

#+end_src

Map Dvorak programmer number key rows to the number they corresponding to, so that I don't need to use Shift key when selecting words.
#+begin_src emacs-lisp
  (setup pyim
    (dolist (d (number-sequence 0 9))
      (:bind (alist-get d my-dvp-digit-row-alist)
             (lambda ()
               (interactive)
               (pyim-select-word-by-number (1+ d))))))
#+end_src

*** vterm
#+begin_src scheme
  (simple-service
   'home-emacs-vterm
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-vterm")))))
#+end_src

#+begin_src scheme
  (simple-service
   'fish-vterm-setup
   home-fish-service-type
   (home-fish-extension
    (config
     (list (mixed-text-file "fish-vterm.fish"
                            "if test \"$INSIDE_EMACS\" = 'vterm';"
                            "  source $EMACS_VTERM_PATH/etc/emacs-vterm.fish;"
                            "end")))))
#+end_src

#+begin_src emacs-lisp
  (setup vterm
    (:option vterm-shell "~/.guix-home/profile/bin/fish")
    (:unbind "C-SPC")

    (defun my-project-vterm ()
      "Start a project-specific vterm buffer, or switch to the existing one."
      (interactive)
      (defvar vterm-buffer-name)
      (let* ((default-directory (project-root (project-current t)))
             (vterm-buffer-name (project-prefixed-buffer-name "vterm"))
             (vterm-buffer (get-buffer vterm-buffer-name)))
        (if (and vterm-buffer (not current-prefix-arg))
            (pop-to-buffer vterm-buffer (bound-and-true-p display-comint-buffer-action))
          (vterm t))))

    (defun my-project-vterm-command (cmd)
      (interactive
       (list (read-shell-command (if shell-command-prompt-show-cwd
                                     (format-message "Shell command in `%s': "
                                                     (abbreviate-file-name
                                                      default-directory))
                                   "Shell command: ")
                                 nil nil)))
      (unless (string-empty-p cmd)
        (with-current-buffer (call-interactively #'my-project-vterm)
          (vterm-send-string (concat cmd "\n"))
          (when (evil-normal-state-p)
            (evil-collection-vterm-insert))))))
#+end_src

*** COMMENT Eat
[[https://codeberg.org/akib/emacs-eat][eat]] is a terminal emulator for Emacs, similar to =vterm=, but implemented fully in Elisp.
#+begin_src scheme
  (simple-service
   'home-emacs-eat
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-eat")))))
#+end_src

Note that I disable Eat for now, because ~eat-eshell-mode~ hang the whole Emacs when some non-ASCII characters are printed. Nevertheless, here is the config:
#+begin_src emacs-lisp
  (setup eat
    (:option eshell-visual-commands nil
             eshell-visual-subcommands nil
             eshell-visual-options nil)
    (:with-map eat-eshell-semi-char-mode-map
      (:unbind "C-SPC"))
    (eat-eshell-mode +1))
#+end_src

*** Dired
=dired= is Emacs' built-in file explorer. It has a classic text-based UI that is so easy to use that many community-maintained packages follow its design principles.

#+begin_src emacs-lisp
  (setup dired
    (:hook #'dired-hide-details-mode)
    (:option dired-listing-switches "-alh"))
#+end_src

I re-enabled ~dired-dwim-target~.  It automatically pick the directory shows in the "other Dired buffer" as the first candidate for Dired operations.
#+begin_src emacs-lisp
  (setup dired
    (:option dired-dwim-target t))
#+end_src

When moving through lines, skip empty lines, and don't wrap on the last line.
#+begin_src emacs-lisp
  (setup dired
    (:option dired-movement-style 'bounded))
#+end_src

Dired decompress files by matching against ~dired-compress-file-suffixes~.  However, it misses the rule for uncompressing =.tar.bz2=, and weirdly it compress =.tar= to =.tgz= instead of unarchive it.  For better consistency, here is my config:
#+begin_src emacs-lisp
  (setup dired-aux
    (:when-loaded
      (:option (prepend* dired-compress-file-suffixes)
               `((,(rx ".tar.bz2" eos) "" "bunzip2 -kc %i | tar -xf -")
                 (,(rx ".tar" eos) "" "tar -xf %i")))))
#+end_src

**** dired-rsync
One thing that dired (with tramp) does it badly is copying files over network. For small files it is fine, for big files not only is it slow but also it blocks the whole Emacs while copying. [[https://github.com/stsquad/dired-rsync][dired-rsync]] to the rescue, which basically wraps [[https://rsync.samba.org/][rsync]] and does things asynchronously.
#+begin_src scheme
  (simple-service
   'home-emacs-dired-rsync
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-dired-rsync")))))
#+end_src

#+begin_src emacs-lisp
  (setup (:package dired-rsync)
    (:option dired-rsync-options "-azs --info=progress2"))
#+end_src

*** EMMS
[[https://www.gnu.org/software/emms/][EMMS]], short for Emacs Multimedia System, "displays and plays multimedia from within Emacs using a variety of external players and from different sources".
#+begin_src scheme
  (simple-service
   'home-emacs-emms
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-emms-with-convert")))))
#+end_src

It's manual:
#+begin_src emacs-lisp
  (setup info
    (:when-loaded
      (:option (prepend Info-url-alist)
               `(("emms") . ,(my-info-url-alist-single-page-entry "https://www.gnu.org/software/%m/manual/")))))
#+end_src

#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-emms-with-convert
    (package
      (inherit upstream:emacs-emms)
      (name "emacs-emms-with-convert")
      (inputs
       (modify-inputs (package-inputs upstream:emacs-emms)
                      (prepend (@(gnu packages imagemagick) imagemagick))))
      (arguments
       (substitute-keyword-arguments (package-arguments upstream:emacs-emms)
         ((#:phases phases)
          `(modify-phases ,phases
             (add-after 'set-external-programs 'set-external-programs-convert
               (lambda* (#:key inputs #:allow-other-keys)
                 (let ((imagemagick (assoc-ref inputs "imagemagick")))
                   (emacs-substitute-variables "emms-browser.el"
                     ("emms-browser-thumbnail-convert-program"
                      (string-append imagemagick "/bin/convert")))
                   (substitute* "emms-browser.el"
                     (("\\(executable-find \"convert\"\\)") "emms-browser-thumbnail-convert-program")))))))))))
#+end_src

#+begin_src emacs-lisp
  (setup emms
    (:also-load emms-source-file
                emms-source-playlist
                emms-source-beets
                emms-player-mpv
                emms-info-libtag
                emms-cache
                emms-browser)
    (:option emms-directory (exdg-state "emms")
             emms-cache-file (exdg-cache "emms-cache")
             emms-browser-thumbnail-directory (exdg-cache "emms-thumbnail")
             emms-player-list '(emms-player-mpv)
             emms-info-functions '(emms-info-native)))
#+end_src

Always center to the playing song when opening the playlist.
#+begin_src emacs-lisp
  (setup emms
    (:option emms-playlist-mode-center-when-go t))
#+end_src

#+begin_src emacs-lisp
  (setup emms
    (:when-loaded
      (:option (prepend* emms-player-mpv-parameters)
               '("--volume=40"))))
#+end_src

#+begin_src emacs-lisp
  (setup emms
    (:option emms-track-initialize-functions '(emms-info-initialize-track))
    (:option emms-info-functions '(emms-info-libtag))
    (:option emms-track-description-function #'emms-info-track-description)
    (:option emms-browser-covers #'emms-browser-cache-thumbnail-async))
#+end_src

As far as I can tell, the browser feature depends on the cache feature, so we have no choose but turn it on.
#+begin_src emacs-lisp
  (setup emms-cache
    (:when-loaded
      (emms-cache +1)))
#+end_src

#+begin_src emacs-lisp
  (setup emms-source-beets
    (:option emms-source-beets-database
             (expand-file-name "library.db" (xdg-user-dir "MUSIC"))))
#+end_src

#+begin_src emacs-lisp
  (define-advice emms-browser-remove-tracks
      (:filter-args (args) dont-delete-my-files)
    "Just don't delete files, period."
    (let* ((linum-or-delete (car args))
           (rest (cdr args))
           (d (if (numberp linum-or-delete)
                  linum-or-delete
                nil)))
      `(,d ,@rest)))
#+end_src

*** Guix
#+begin_src scheme
  (simple-service
   'home-emacs-guix
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-guix")))))
#+end_src

#+end_src

*** Desktop Notification Daemon
[[https://github.com/sinic/ednc][ednc]] enables Emacs to be the desktop notification daemon listening D-bus, similar to [[https://dunst-project.org/][Dunst]].
#+begin_src scheme
  (simple-service
   'home-emacs-ednc
   home-emacs-service-type
   (home-emacs-extension
    (packages
     (list
      (specification->package
       "emacs-ednc")))))
#+end_src

The following configuration let a posframe show up whenever there are new notifications. When the posframe is presented, I can use =C-g= to dismiss the latest notification, and when there is none the posframe will be automatically closed (well, invisible actually).
#+begin_src emacs-lisp
  (setup ednc
    (:system 'gnu/linux)
    (defvar my-ednc-posframe--buffer "*ednc-posframe*"
      "Buffer used for ednc notification posframe display.")

    (defun my-ednc-posframe-show ()
      (interactive)
      (when (and (buffer-live-p (get-buffer my-ednc-posframe--buffer))
                 (posframe-workable-p))
        (posframe-show my-ednc-posframe--buffer
                       :poshandler #'posframe-poshandler-frame-top-center
                       :border-width 1)))

    (defun my-ednc-posframe-hide ()
      (interactive)
      (when (posframe-workable-p)
        (posframe-hide my-ednc-posframe--buffer)))

    (defun my-ednc-posframe--update (&rest _)
      (let ((notifications (ednc-notifications)))
        (with-current-buffer (get-buffer-create my-ednc-posframe--buffer)
          (erase-buffer)
          (insert (mapconcat
                   (lambda (n) (ednc-format-notification n :expand))
                   notifications "")))
        (when (posframe-workable-p)
          (if notifications
              (my-ednc-posframe-show)
            (my-ednc-posframe-hide)))))

    (defun my-ednc--dismiss-first-notification ()
      (when-let* ((buffer (get-buffer my-ednc-posframe--buffer))
                  (frame (with-current-buffer buffer
                           posframe--frame))
                  ((frame-visible-p frame))
                  (notification (ednc-notifications)))
        (ednc-dismiss-notification (car notification))))

    (advice-add #'keyboard-quit :before #'my-ednc--dismiss-first-notification)

    (:when-loaded
      (:with-hook ednc-notification-presentation-functions
        (:hook #'my-ednc-posframe--update)))
    (:enable))
#+end_src

* References and Recommendations
This configuration is written while referencing the following guix configurations:
- [[https://git.sr.ht/~akagi/guixrc][Aleksandr Vityazev's Guix Configuration]]
- [[https://github.com/dustinlyons/guix-config][Dustin Lyon's Literate Configuration for Guix Linux]]
- [[https://git.envs.net/iyzsong/guixrc.git][iyzsong's Guix System and Home Config]]
- [[https://git.sr.ht/~krevedkokun/dotfiles][Nikita Domnitskii's Dotfiles]]
- [[https://github.com/nicolas-graves/dotfiles][Nicolas Graves's Dotfiles]]
- [[https://github.com/qbladea/linux-os][Luhux  Guix ]]
- [[https://git.sr.ht/~abcdw/rde][rde by Andrew Tropin]]. I use it as a channel.
- [[https://github.com/tumashu/geeguix][Tumashu's Guixsd Configuration]]
- [[https://codeberg.org/hako/Rosenthal/][Rosenthal by Hako]], a Guix channel
- [[https://github.com/yveszoundi/guix-config/][Yves Zoundi's Guix Configuration]]
