# -*- org-use-property-inheritance: t; -*-
#+title: hiecaq's guix configuration
#+startup: indent
#+property: header-args :comments org :results silent :mkdirp t

* Table of Contents :TOC:noexport:
- [[#introduction][Introduction]]
- [[#home-configuration][Home Configuration]]
- [[#guix][Guix]]
  - [[#locales][Locales]]
  - [[#channels][Channels]]
- [[#cross-desktop-group-xdg][Cross-Desktop Group (XDG)]]
  - [[#base-directories][Base Directories]]
  - [[#user-directories][User Directories]]
- [[#shells][Shells]]
  - [[#zsh][Zsh]]
  - [[#tools][Tools]]
  - [[#aliases][Aliases]]
- [[#fonts][Fonts]]
- [[#references-and-recommendations][References and Recommendations]]

* Introduction
This is my all-in-one [[https://guix.gnu.org/][Guix]] configuration, working in progress. This aims to eventually replace and deprecate [[https://github.com/hiecaq/dotfiles][my dotfiles]], which has too many historical burdens.

Unless explicitly stated, all code in this configuration is under GPL3 license.

* Home Configuration
This is the main entry point for =guix home=. It can be tested with
#+begin_src sh
  guix home -L build container build/home-configuration.scm
#+end_src
and deployed with
#+begin_src sh
  guix home -L build reconfigure build/home-configuration.scm
#+end_src

#+begin_src scheme :tangle "build/home-configuration.scm" :noweb yes
  (use-modules
   (gnu home)
   (gnu services)
   (gnu packages)
   <<home-module>>
   )

  (home-environment
   <<home-environment-conf>>
   (services
    (append
     <<home-environment-service>>
     )))
#+end_src

This basically reads the default essential service list, and modifies it as needed. ~home-environment-default-essential-services~ is private, so we have to use [[https://www.gnu.org/software/guile/manual/html_node/Using-Guile-Modules.html][@@]] syntax to force importing it. Maybe there is a better way.
#+begin_src scheme :noweb-ref home-environment-conf
  (essential-services
   (fonts:modify-essential-service
    ((@@(gnu home) home-environment-default-essential-services)
     this-home-environment)))
#+end_src

This is a list of packages that are not installed by services. Eventually this list should be empty.
#+begin_src scheme :noweb-ref home-environment-conf
  (packages (specifications->packages
             (list
              "neovim"
              "guile"
              )))
#+end_src

* Guix
This file defines those settings related to Guix itself.
#+begin_src scheme :tangle "build/hiecaq/home/guix.scm" :noweb yes
  (define-module (hiecaq home guix)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (gnu home services guix)
    #:use-module (guix channels))

  (define-public services
    (list
     <<guix-service>>
     (simple-service
      'variant-packages-service
      home-channels-service-type
      (list
       <<guix-channel>>
       ))))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home guix) #:prefix guix:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  guix:services
#+end_src

** Locales
Set the locales as recommended in [[https://guix.gnu.org/manual/en/html_node/Application-Setup.html][the manual]].
#+begin_src scheme :noweb-ref guix-service
  (service
   (service-type
    (name 'home-locale)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "glibc-locales"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("GUIX_LOCPATH" . "${GUIX_PROFILE}/lib/locale"))))))
    (default-value #f)
    (description #f)))
#+end_src

** Channels
:PROPERTIES:
:header-args:scheme: :noweb-ref guix-channel
:END:
[[https://git.sr.ht/~abcdw/rde][rde]] is a "developers and power user friendly GNU/Linux distribution based on GNU Guix package manager", which can be used as a channel directly. In this way, I can use the helper procedures that it defines.
#+begin_src scheme
  (channel
   (name 'rde)
   (url "https://git.sr.ht/~abcdw/rde")
   (introduction
    (make-channel-introduction
     "257cebd587b66e4d865b3537a9a88cccd7107c95"
     (openpgp-fingerprint
      "2841 9AC6 5038 7440 C7E9  2FFA 2208 D209 58C1 DEB0"))))
#+end_src

* Cross-Desktop Group (XDG)
This section defines those settings related to the [[https://www.freedesktop.org/wiki/Specifications/][XDG]] specifications.
#+begin_src scheme :tangle "build/hiecaq/home/xdg.scm" :noweb yes
  (define-module (hiecaq home xdg)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (gnu home services xdg)
    #:use-module (guix channels))

  (define-public services
    (list
     <<xdg-service>>
     ))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home xdg) #:prefix xdg:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  xdg:services
#+end_src

** Base Directories
See [[https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html][Enviroment Variables chapter in latest XDG Base Directory Specification]] for the description on their purposes.

Guix home [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/home.scm#n86][instantiate]] [[https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/home/services/xdg.scm#n148][it]] by default, so technically there is no configuration needed, unless we want to modify their values.

Note that their values are set in =$GUIX_HOME/setup-environment=, which should be run by =$HOME/.profile=, which is sourced at the beginning of a login shell.

** User Directories
As declared in [[https://www.freedesktop.org/wiki/Software/xdg-user-dirs/][xdg-user-dirs]], this defines "well known" user directories, and their localization.
#+begin_src scheme :noweb-ref xdg-service
  (simple-service
   'xdg-user-directories-config-service
   home-xdg-user-directories-service-type
   (home-xdg-user-directories-configuration
    (desktop     "$HOME/desktop")
    (documents   "$HOME/documents")
    (download    "$HOME/downloads")
    (music       "$HOME/music")
    (pictures    "$HOME/pictures")
    (publicshare "$HOME/public")
    (templates   "$HOME/templates")
    (videos      "$HOME/videos")))
#+end_src

* Shells
#+begin_src scheme :tangle "build/hiecaq/home/shell.scm"
  (define-module (hiecaq home shell)
    #:use-module (gnu home)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (guix channels)
    #:use-module (gnu home services guix)
    #:use-module (gnu home-services shellutils)
    #:use-module (guix gexp)
    #:use-module (rde gexp)
    #:use-module (rde home services shells))
#+end_src

TODO: I should split this out later.
#+begin_src scheme :tangle "build/hiecaq/home/shell.scm" :noweb yes
  (define-public services
    (list
     (simple-service
      'extend-environment-variables
      home-environment-variables-service-type
      `(("PS1" . "$ ")
        ("EDITOR" . "nvim")
        ("VISUAL" . "nvim")
        ("MANPAGER" . "nvim +Man!")
        ("MANWIDTH" . "80")
        ("QT_AUTO_SCREEN_SCALE_FACTOR" . "1")))
     <<shell-service>>
     ))
#+end_src

Add this module and its services:
#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home shell) #:prefix shell:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  shell:services
#+end_src

** Zsh
:PROPERTIES:
:header-args:scheme: :noweb-ref shell-service
:END:
I'm currently using [[https://www.zsh.org/][zsh]] as my primary shell.
#+begin_src scheme
  (service
   home-zsh-service-type
   (home-zsh-configuration
    (zshrc
     (list (slurp-file-like (local-file "../../.zshrc"
                                        "zshrc"))
           (slurp-file-like (local-file "../../.aliases"
                                        "aliases"))))))
#+end_src

*** syntax highlighting
Add [[https://github.com/zsh-users/zsh-syntax-highlighting][zsh-syntax-highlighting]], which provides "fish shell like syntax highlighting for Zsh."
#+begin_src scheme
  (service
   (service-type
    (name 'home-zsh-syntax-highlighting)
    (extensions
     (list
      (service-extension home-zsh-plugin-manager-service-type
                         (const
                          (list
                           (specification->package
                            "zsh-syntax-highlighting"))))
      (service-extension
       home-zsh-service-type
       (const
        (home-zsh-extension
         (zshrc '("# Improve highlighting")))))))
    (default-value #f)
    (description #f)))
#+end_src
And its configuration
#+begin_src sh :tangle "build/.zshrc"
  # Declare the variable
  typeset -A ZSH_HIGHLIGHT_STYLES

  # disable highlighting for unknown-token
  ZSH_HIGHLIGHT_STYLES[unknown-token]='none'

  # use blue to highlight command(e.g., git)
  ZSH_HIGHLIGHT_STYLES[command]='fg=004'

  # builtins(e.g., pwd): blue, italic
  ZSH_HIGHLIGHT_STYLES[builtin]='fg=004,standout'

  # commandseparator(;, &&): lighter gray
  ZSH_HIGHLIGHT_STYLES[commandseparator]='fg=014'

  # alias: blue
  ZSH_HIGHLIGHT_STYLES[alias]='fg=004'

  # single hyphen-option: darker red,italic
  ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=001'

  # double hyphen-option: darker red
  ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=001'

  # quoted arguments(strings)
  ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=006'
  ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=006'

  # dollar quoted arguments:gold
  ZSH_HIGHLIGHT_STYLES[dollar-quoted-argument]='fg=003'

  # other commands: red
  ZSH_HIGHLIGHT_STYLES[arg0]='fg=001'

  # To define styles for nested brackets up to level 4
  ZSH_HIGHLIGHT_STYLES[bracket-level-1]='fg=010'
  ZSH_HIGHLIGHT_STYLES[bracket-level-2]='fg=014'
  ZSH_HIGHLIGHT_STYLES[bracket-level-3]='fg=010'
  ZSH_HIGHLIGHT_STYLES[bracket-level-4]='fg=014'
  ZSH_HIGHLIGHT_STYLES[bracket-error]='fg=001'
  ZSH_HIGHLIGHT_STYLES[cursor-matchingbracket]='fg=007'

  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets)
#+end_src

** Tools
:PROPERTIES:
:header-args:scheme: :noweb-ref shell-service
:END:
There are many tools that enhance the command line user experience.
*** bat
Add [[https://github.com/sharkdp/bat][bat]], which is a =cat= clone with colors.
#+begin_src scheme
  (service
   (service-type
    (name 'home-bat)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "bat"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("BAT_THEME" . "TwoDark"))))))
    (default-value #f)
    (description #f)))
#+end_src

*** exa
Add [[https://github.com/ogham/exa][exa]], which is "a modern replacement for =ls=".
#+begin_src scheme
  (service
   (service-type
    (name 'home-exa)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "exa"))))
      (service-extension
       home-environment-variables-service-type
       (const '(("EXA_COLORS" .
                 "*.zip=0:*.gz=0:*.rar=0:*.tar=0:*.7z=0:ex=31:di=244;1"))))))
    (default-value #f)
    (description #f)))
#+end_src

*** ripgrep
Add [[https://github.com/BurntSushi/ripgrep][ripgrep]], which is "a line-oriented search tool that recursively searches the current directory for a regex pattern". In other words, it is a modern =grep=.
#+begin_src scheme
  (simple-service
   'home-ripgrep
   home-profile-service-type
   (list
    (specification->package
     "ripgrep")))
#+end_src

*** fd
Add [[https://github.com/sharkdp/fd][fd]], which is "a simple, fast and user-friendly alternative to 'find'".
#+begin_src scheme
  (simple-service
   'home-fd
   home-profile-service-type
   (list
    (specification->package
     "fd")))
#+end_src

** Aliases
And the aliases that I'm using:
#+begin_src sh :tangle "build/.aliases"
  alias v="nvim"
  alias e="emacsclient -c --no-wait"
  alias g="git"
  alias ls="exa"
  alias l="exa --git-ignore"
  alias l.="ls -lah"
  alias gc="git commit -v"
#+end_src
* Fonts
:PROPERTIES:
:header-args:scheme: :tangle "build/hiecaq/home/fonts.scm"
:END:

This file describe how fonts are configured.
#+begin_src scheme
  (define-module (hiecaq home fonts)
    #:use-module (gnu services)
    #:use-module (gnu home services)
    #:use-module (gnu packages fonts)
    #:use-module (gnu packages fontutils)
    #:use-module (guix gexp)
    #:use-module ((gnu home services fontutils) #:prefix fontutils:))
#+end_src

The ~home-fontconfig-service-type~ from vanilla =guix= comes with a =fonts.conf= that is literately inconfigurable, so we have to overwrite it.
SIDE NOTES: I cannot use ~@@~ to import ~regenerate-font-cache-gexp~ from =(gnu home services fontutils)= I have totally no idea why.
#+begin_src scheme
  (define (add-fontconfig-config-file he-symlink-path)
    `(("fontconfig/fonts.conf"
       ,(local-file "../../fonts.conf"))))

  (define (regenerate-font-cache-gexp _)
    `(("profile/share/fonts"
       ,#~(system* #$(file-append fontconfig "/bin/fc-cache") "-fv"))))

  (define home-fontconfig-service-type
    (service-type (name 'home-fontconfig)
                  (extensions
                   (list (service-extension
                          home-xdg-configuration-files-service-type
                          add-fontconfig-config-file)
                         (service-extension
                          home-run-on-change-service-type
                          regenerate-font-cache-gexp)
                         (service-extension
                          home-profile-service-type
                          (const (list fontconfig)))))
                  (default-value #f)
                  (description
                   "Provides configuration file for fontconfig and make
  fc-* utilities aware of font packages installed in Guix Home's profile.")))

  (define-public (modify-essential-service services)
    `(,@(modify-services
         services
         (delete fontutils:home-fontconfig-service-type))
      ,(service home-fontconfig-service-type)))
#+end_src

Here is the modified =fonts.conf=:
#+begin_src nxml :tangle "build/fonts.conf" :comments no
  <?xml version="1.0"?>
  <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
  <fontconfig>
      <dir>~/.guix-home/profile/share/fonts</dir>
      <alias>
          <family>serif</family>
          <prefer>
              <family>Noto Serif</family>
              <family>Noto Serif CJK SC</family>
              <family>Noto Serif CJK JP</family>
              <family>Noto Serif CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>sans-serif</family>
          <prefer>
              <family>Noto Sans</family>
              <family>Noto Sans CJK SC</family>
              <family>Noto Sans CJK JP</family>
              <family>Noto Sans CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>monospace</family>
          <prefer>
              <family>Noto Sans Mono</family>
              <family>Noto Sans Mono CJK SC</family>
              <family>Noto Sans Mono CJK JP</family>
              <family>Noto Sans Mono CJK TC</family>
          </prefer>
      </alias>
      <alias>
          <family>emoji</family>
          <prefer>
              <family>Noto Color Emoji</family>
          </prefer>
      </alias>
  </fontconfig>
#+end_src

this module simply provides a single service that install the fonts needed.
#+begin_src scheme
  (define-public services
    (list (simple-service
           'extend-environment-variables
           home-profile-service-type
           (list
            font-hack
            font-google-noto
            font-google-noto-sans-cjk))))
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-module
  ((hiecaq home fonts) #:prefix fonts:)
#+end_src

#+begin_src scheme :tangle no :noweb-ref home-environment-service
  fonts:services
#+end_src

* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle "build/init.el"
:header-args:scheme: :noweb-ref emacs-service
:END:
TODO: I'm still not sure if I should put some config as big as Emacs' in this file.
#+begin_src scheme :tangle "build/hiecaq/home/emacs.scm" :noweb yes :noweb-ref nil
  (define-module (hiecaq home emacs)
    #:use-module (gnu services)
    #:use-module (gnu packages)
    #:use-module (gnu home services)
    #:use-module (guix gexp))

  (define-public services
    (list
     <<emacs-service>>))
#+end_src

Add this module and its services:
#+begin_src scheme :noweb-ref home-module
  ((hiecaq home emacs) #:prefix emacs:)
#+end_src

#+begin_src scheme :noweb-ref home-environment-service
  emacs:services
#+end_src
** Basics
I'm currently using =emacs-next= from Guix official channel.
#+begin_src scheme
  (service
   (service-type
    (name 'home-emacs)
    (extensions
     (list
      (service-extension
       home-profile-service-type
       (const (list
               (specification->package
                "emacs-next"))))
      (service-extension
       home-xdg-configuration-files-service-type
       (const `(("emacs/init.el" ,(local-file "../../init.el"))
                ("emacs/early-init.el" ,(local-file "../../early-init.el")))))
      (service-extension
       home-environment-variables-service-type
       (const '(("EDITOR" . "emacsclient -a nvim -c")
                ("VISUAL" . "emacsclient -a nvim -c"))))))

    (default-value #f)
    (description #f)))
#+end_src

I and my Guix packages definition is at =(hiecaq packages emacs-xyz)=. TODO: makes a channel!
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-module (hiecaq packages emacs-xyz)
    #:use-module (guix packages)
    #:use-module (guix git-download)
    #:use-module (guix build-system emacs)
    #:use-module (gnu packages)
    #:use-module ((gnu packages emacs-xyz) #:prefix upstream:)
    #:use-module ((guix licenses) #:prefix license:))
#+end_src

NOTE: the hash for git-based packages is got by following [[https://guix.gnu.org/cookbook/en/html_node/Extended-example.html][Guix Cookbook instructions]].

** Early Initialization
:PROPERTIES:
:header-args:emacs-lisp: :tangle "build/early-init.el"
:END:
#+begin_src emacs-lisp :comments no
  ;;; early-init.el --- Configurations before package systems and UI systems -*- lexical-binding: t; buffer-read-only: t; eval: (auto-revert-mode 1) -*-
#+end_src
*** Packages
I don't use the built-in =package.el= to fetch packages, so I'll turn it off:
#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

*** Special Key Remapping
grabbed from [[https://emacsnotes.wordpress.com/2022/09/11/three-bonus-keys-c-i-c-m-and-c-for-your-gui-emacs-all-with-zero-headache/][Three bonus keys—‘C-i’, ‘C-m’ and ‘C-[’—for your GUI Emacs; all with zero headache]]
#+begin_src emacs-lisp
  (add-hook
   'after-make-frame-functions
   (defun setup-blah-keys (frame)
     (with-selected-frame frame
       (when (display-graphic-p)
         (define-key input-decode-map (kbd "C-i") [CTRL-i])
         (define-key input-decode-map (kbd "C-[") [CTRL-lsb]) ; left square bracket
         (define-key input-decode-map (kbd "C-m") [CTRL-m])))))
#+end_src

*** Some Configurations that might make sense to put here
~load~ prefers the newest version of a file (when suffix is not given).
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Main Configurations
Init file header:
#+begin_src emacs-lisp :comments no
  ;;; init.el --- Main Configurations -*- lexical-binding: t; buffer-read-only: t; eval: (auto-revert-mode 1) -*-
#+end_src

Use Utf-8 as the default coding system.
#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8-unix)
#+end_src
*** setup.el
[[https://www.emacswiki.org/emacs/SetupEl][setup.el]] provides "context sensitive local macros" to "ease repetitive configuration patterns in Emacs". It is considered as an alternative to the now built-in [[https://github.com/jwiegley/use-package][use-package]].
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-setup")))
#+end_src

See Alternative Macro Definer at [[https://www.emacswiki.org/emacs/SetupEl][its Emacs Wiki page]], and [[https://github.com/mfiano/emacs-config/blob/main/lisp/mf-setup.el][Michael Fiano's Emacs Configuration on this]]. Many of the following tweaks are based on them, with some modifications, mainly for the Emacs 29 changes.

TODO: I should split this out later.
#+begin_src emacs-lisp
  (require 'setup)
  (require 'cl-macs)

  (defmacro defsetup (name signature &rest body)
    "Shorthand for `setup-define'.
  NAME is the name of the local macro.  SIGNATURE is used as the
  argument list for FN.  If BODY starts with a string, use this as
  the value for :documentation.  Any following keywords are passed
  as OPTS to `setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
        (setq opts (nconc (list :documentation (pop body))
                          opts)))
      (while (keywordp (car body))
        (let* ((prop (pop body))
               (val `',(pop body)))
          (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
         (cl-function (lambda ,signature ,@body))
         ,@opts)))

  (put #'defsetup 'lisp-indent-function 'defun)
  ;; use Emacs 29's new `setopt'
  (setup-define :option
    (setup-make-setter
     (lambda (name)
       `(funcall (or (get ',name 'custom-get)
                     #'symbol-value)
                 ',name))
     (lambda (name val)
       `(setopt ,name ,val)))

    :documentation "Set the option NAME to VAL.
  NAME may be a symbol, or a cons-cell.  If NAME is a cons-cell, it
  will use the car value to modify the behaviour.  These forms are
  supported:

  (append VAR)    Assuming VAR designates a list, add VAL as its last
                  element, unless it is already member of the list.

  (prepend VAR)   Assuming VAR designates a list, add VAL to the
                  beginning, unless it is already member of the
                  list.

  (remove VAR)    Assuming VAR designates a list, remove all instances
                  of VAL.

  Note that if the value of an option is modified partially by
  append, prepend, remove, one should ensure that the default value
  has been loaded. Also keep in mind that user options customized
  with this macro are not added to the \"user\" theme, and will
  therefore not be stored in `custom-set-variables' blocks."
    :debug '(sexp form)
    :repeatable t)

  (defsetup :global (&rest body)
    "Use the global keymap for the BODY. This is intended to be used with ':bind'."
    :indent 1
    :debug '(sexp)
    (let (bodies)
      (push (setup-bind body (map 'global-map))
            bodies)
      (macroexp-progn (nreverse bodies))))

  (defsetup :with-state (state &rest body)
    "Change the evil STATE that BODY will bind to. If STATE is a list, apply BODY
  to all elements of STATE. This is intended to be used with ':bind'."
    :indent 1
    :debug '(sexp setup)
    (let (bodies)
      (dolist (state (ensure-list state))
        (push (setup-bind body (state state))
              bodies))
      (macroexp-progn (nreverse bodies))))

  (defsetup :bind (key command)
    "Bind KEY to COMMAND in current map, and optionally for current evil states."
    :after-loaded t
    :debug '(form sexp)
    :repeatable t
    :ensure (nil func)
    (let* ((map (setup-get 'map))
           (global (or (not map) (eq map 'global) (eq map 'global-map)))
           (state (ignore-errors (setup-get 'state))))
      (cond
       ((and state global)
        `(with-eval-after-load 'evil
           (evil-define-key* ',state 'global ,(kbd key) ,command)))
       (state
        `(with-eval-after-load 'evil
           (evil-define-key* ',state ,map ,(kbd key) ,command)))
       (global `(keymap-global-set ,key ,command))
       (t `(keymap-set ,map ,key ,command)))))

  (defsetup :unbind (key)
    "Unbind KEY in current map, and optionally for current evil states."
    :after-loaded t
    :debug '(form)
    :repeatable t
    (let* ((map (setup-get 'map))
           (global (or (not map) (eq map 'global) (eq map 'global-map)))
           (state (ignore-errors (setup-get 'state))))
      (cond
       ((and state global)
        `(with-eval-after-load 'evil
           (evil-define-key* ',state 'global ,(kbd key) nil)))
       (state
        `(with-eval-after-load 'evil
           (evil-define-key* ',state ,map ,(kbd key) nil)))
       (global `(keymap-global-unset ,key :remove))
       (t `(keymap-unset ,map ,key :remove)))))

  (defsetup :needs (executable)
    "If EXECUTABLE is not in the path, stop here."
    :debug '(form)
    `(unless (executable-find ,executable)
       ,(setup-quit)))

  (defsetup :enable ()
    "Enable the current mode."
    :debug '(form)
    `(,(setup-get 'mode) 1))
#+end_src

*** Some Sane Configurations
#+begin_src emacs-lisp
  (setup simple
    (:option indent-tabs-mode nil))

  (setup frame
    (:option blink-cursor-mode nil))

  (setup scroll-bar
    (:option scroll-bar-mode nil))

  (setup tool-bar
    (:option tool-bar-mode nil))

  (setup menu-bar
    (:option menu-bar-mode nil))
#+end_src

Turn off lockfiles. They cannot be moved to a different directory, and they consistently screw up with file watchers and version control systems. It'd be just easier to turn this feature off.
#+begin_src emacs-lisp
  (setup emacs
    (:option create-lockfiles nil))
#+end_src

4-space indentation:
#+begin_src emacs-lisp
  (setup simple
    (:option tab-width 4))
#+end_src

General programming set up:
#+begin_src emacs-lisp
  (setup prog-mode
    (:hook #'display-line-numbers-mode)
    (:local-set truncate-lines t))
#+end_src

When Emacs writes buffers to files, by the high-level sense it replace the existing file with the content in the buffer. The buffer itself can be backuped, so that if Emacs crashes before the writing, the dirty content can be recovered. How it replaces the content is configurable, and I want to always prefer copying the existing file and then writing the buffer on top of the existing file. See [[help:make-backup-files][help]] for details.
#+begin_src emacs-lisp
  (setup files
    (:option backup-by-copying t))
#+end_src

Always use =y-or-p= over =yes-or-no=:
#+begin_src emacs-lisp
  (setup emacs
    (:option use-short-answers t))
#+end_src

I don't want Emacs to auto-recenter when scrolling off-the-screen:
#+begin_src emacs-lisp
  (setup emacs
    (:option scroll-conservatively 100))
#+end_src

One extra thing: Emacs comes with a customization interface, which supports setting via function calls too (good!) and saves the results in a file (bad!). This snippet set the storage to =/dev/null=:
#+begin_src emacs-lisp
  (setup cus-edit
    (:option custom-file null-device))
#+end_src

*** Help
TODO: this should not require help.
#+begin_src emacs-lisp
  (setup (:require help)
    (:global (:unbind "C-h C-h")))
#+end_src

*** No Littering
[[https://github.com/emacscollective/no-littering][no-littering]] helps put emacs directory clean, sorting package-created files and directories into reasonable directories. One thing it misses is the distinguishing between permanent data and temporary data. I used to fork it to provide this distinguishing, but it turns out to be too troublesome to maintain. Now I simply consider this as a "fallback" solution. Later on for the variables from packages I really use I'll overwrite them manually.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-no-littering")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require no-littering))
#+end_src

*** Modus Themes
#+begin_src scheme
  (simple-service
   'home-emacs-modus-themes
   home-profile-service-type
   (list
    (specification->package
     "emacs-modus-themes")))
#+end_src

#+begin_src emacs-lisp
  (setup modus-themes
    (:option modus-themes-mixed-fonts t)
    (:require modus-themes)
    (load-theme 'modus-vivendi :no-confirm))
#+end_src

*** Recentf
[[info:emacs#File Conveniences][recentf]] is an Emacs built-in minor mode that saves recent file list.
#+begin_src emacs-lisp
  (setup recentf
    (:enable))
#+end_src

*** Save History
[[help:savehist-mode][savehist]] is an Emacs built-in minor mode that save minibuffer histories to a file.
#+begin_src emacs-lisp
  (setup savehist
    (:enable))
#+end_src

***  COMMENT Save Place
[[https://www.emacswiki.org/emacs/SavePlace][Save Place]] is a Emacs built-in mode that "nave place in files between sessions".
#+begin_src emacs-lisp
  (setup saveplace
    (:option save-place-forget-unreadable-files nil)
    (save-place-mode 1))
#+end_src

*** Editorconfig
[[https://editorconfig.org/][editorconfig]] is a very handy tool that standardize how different editors should behave according to different language, including tab width, trailing space and so on. It is not only helpful for team to maintain a codestyle standard, but also a handful tool for people use several different editors / computers, like I do.

[[https://github.com/editorconfig/editorconfig-emacs][editorconfig-emacs]] implements its own =editorconfig= core, so it's logical to assume that it works on any platform.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-editorconfig")))
#+end_src

#+begin_src emacs-lisp
  (setup editorconfig
    (:enable))
#+end_src

*** Subword
[[help:subword-mode][subword-mode]] is an Emacs built-in that makes =CamelCase= be considered as 2 separate words =Camel= and =Case=. Evil also respects this minor mode. I've found that to turn on this mode is almost always positive for Evil usages, because the =io= =ao= text objects select the whole symbol anyway, pretty much covers the non-subword usage. There is also [[help:superword-mode][superword-mode]] BTW. See [[info:emacs#MixedCase Words][MixedCase Words]] and [[info:emacs#Misc for Programs][Misc for Programs]] in the documentation.
#+begin_src emacs-lisp
  (setup subword
    (:hook-into text-mode prog-mode))
#+end_src

*** Highlight Parentheses
[[https://git.sr.ht/~tsdh/highlight-parentheses.el][highlight-parentheses]], well, highlights parentheses surrounding [[info:emacs#Point][point]].
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-highlight-parentheses
    (let ((version "2.1.1")
          (revision "0")
          (url "https://git.sr.ht/~tsdh/highlight-parentheses.el"))
      (package
        (name "emacs-highlight-parentheses")
        (version version)
        (source
         (origin
           (method git-fetch)
           (uri
            (git-reference
             (url url)
             (commit version)))
           (file-name (git-file-name name version))
           (sha256
            (base32 "0ixjai9w9x4sm1lx9yljl58r7ydbbjlkb0a2pbv316l8qph8w44r"))))
        (build-system emacs-build-system)
        (home-page url)
        (synopsis "Highlights parentheses surrounding point in Emacs")
        (description "Highlight-parentheses.el dynamically highlights
  the parentheses surrounding point based on nesting-level using configurable
  lists of colors, background colors, and other properties.")
        (license license:gpl3))))
#+end_src

#+begin_src scheme
  (simple-service
   'home-emacs-highlight-parentheses
   home-profile-service-type
   (list
    (specification->package
     "emacs-highlight-parentheses")))
#+end_src

The configs here is basically modified a little bit from [[https://protesilaos.com/emacs/modus-themes#h:24bab397-dcb2-421d-aa6e-ec5bd622b913][Note on highlight-parentheses.el]] in Modus Themes documentation.
#+begin_src emacs-lisp
  (setup highlight-parentheses
    (defvar my-highlight-parentheses-use-background t
      "Prefer `highlight-parentheses-background-colors'.")

    (setq my-highlight-parentheses-use-background t) ; Set to nil to disable backgrounds

    (modus-themes-with-colors
      ;; Our preference for setting either background or foreground
      ;; styles, depending on `my-highlight-parentheses-use-background'.
      (if my-highlight-parentheses-use-background

          ;; Here we set color combinations that involve both a background
          ;; and a foreground value.
          (setq highlight-parentheses-background-colors (list bg-cyan-intense
                                                              bg-magenta-intense
                                                              bg-green-intense
                                                              bg-yellow-intense)
                highlight-parentheses-colors (list cyan
                                                   magenta
                                                   green
                                                   yellow))

        ;; And here we pass only foreground colors while disabling any
        ;; backgrounds.
        (setq highlight-parentheses-colors (list green-intense
                                                 magenta-intense
                                                 blue-intense
                                                 red-intense)
              highlight-parentheses-background-colors nil)))
    (:hook-into prog-mode)
    (:with-function highlight-parentheses-minibuffer-setup
      (:hook-into minibuffer-setup)))
#+end_src
*** Evil
It's name tells everything: the Extensible Vi Layer for Emacs, [[https://github.com/emacs-evil/evil][Evil]]. It works pretty well as a Vim simulation, much better than VsCode's or Intellij's. Besides, it is charming combination of Vim's model-based editing with Emacs' keymap system, to some extent, as a personal opinion, better than the native Vim on the model-based editing system.

References:
- [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid
#+begin_src scheme
  (simple-service
   'home-emacs-evil
   home-profile-service-type
   (specifications->packages
    (list
     "emacs-goto-chg"
     "emacs-evil"
     "emacs-evil-collection"
     "emacs-evil-surround"
     "emacs-evil-replace-with-register"
     "emacs-evil-easymotion"
     "emacs-evil-snipe"
     "emacs-evil-commentary")))
#+end_src

#+begin_src emacs-lisp
  (setup evil
    (:option
     evil-want-integration t ;; require by collection
     evil-want-keybinding nil ;; require by collection
     evil-echo-state nil ;; Don't echo the =<INSERT>= etc info in minibuffer.
     evil-undo-system 'undo-redo ;; Use Emacs 28 new ~undo-redo~ as the undo-redo system
     evil-disable-insert-state-bindings t ;; I don't want to use Vim's insert mode bindings in insert state:
     evil-respect-visual-line-mode t ;; When =visual-line-mode= is set (especially in =org-mode=), I want Vim to behave as visual lines are normal lines (i.e. bind =j= to =gj= etc)
     )
    (defvar-keymap my-leader-map)
    (defun my-leader-key ()
      (interactive)
      (set-transient-map my-leader-map))
    (:global
      (:unbind "C-SPC")
      (:bind "C-SPC" #'my-leader-key))
    (:require evil)
    (:enable))

  (setup evil-collection
    (:option evil-collection-setup-minibuffer t)
    (:require evil-collection)
    (evil-collection-init))
#+end_src

**** Evil Surround
[[https://github.com/emacs-evil/evil-surround][evil-surround]] defines operators that change/add/delete delimiters around a text object.
I found that its key bindings conflict with =evil-snipe= a lot, so I remap them to =m=, which stands for markers.
#+begin_src emacs-lisp
  (setup evil-surround
    (:with-state (operator visual)
      (:unbind "s" "S" "g S"))
    (:with-state (normal operator)
      (:bind "m" #'evil-surround-edit
             "M" #'evil-Surround-edit))
    (:with-state visual
      (:bind "m" #'evil-surround-region
             "M" #'evil-Surround-region))
    (:also-load evil)
    (:with-mode global-evil-surround-mode
      (:enable)))
#+end_src

**** Evil Replace With Register
[[https://github.com/Dewdrops/evil-ReplaceWithRegister][evil-replace-with-register]] defines a =rplace= operator.
#+begin_src emacs-lisp
  (setup (:require evil-replace-with-register)
    (:global (:with-state (normal visual)
               (:bind "_" #'evil-replace-with-register))))
#+end_src

**** Evil Snipe
[[https://github.com/hlissner/evil-snipe][evil-snipe]] is a Evil port of Vim's [[https://github.com/rhysd/clever-f.vim][clever-f]] and [[https://github.com/justinmk/vim-sneak][vim-sneak]]. It currently does not support separating the scope for =f/F/t/T= from for =s/S=, which is a little bit annoying.

There is currently a bug in =evil-snipe='s type declarations for ~evil-snipe-scope~, so I forked it. Once the PR is merged, I'll switch back to the upstream version.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-snipe
    (let ((commit "3ad53b8da0dd23093a3f2f0e5c13ecdb08ba8efa")
          (last-release-version "2.0.8") ;; from the el file version header
          (revision "0")
          (url "https://github.com/hiecaq/evil-snipe"))
      (package
       (name "emacs-evil-snipe")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0fk9nl0h1j1ig6pvb4aix3injxi2jyw9djixchxf4aky11znivgj"))))
       (inputs
        (list upstream:emacs-evil))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "2-char searching ala vim-sneak & vim-seek, for evil-mode")
       (description "This library It provides 2-character motions for quickly
  (and more accurately) jumping around text, compared to evil's built-in
  f/F/t/T motions, incrementally highlighting candidate targets as you type.")
       (license license:expat))))
#+end_src

#+begin_src emacs-lisp
  (setup (:require evil-snipe)
    (:with-map evil-snipe-local-mode-map
      (:with-state (normal motion operator visual)
        (:unbind "s" "S" "z" "Z" "x" "X")
        (:bind "s" #'evil-snipe-s
               "S" #'evil-snipe-S))
      (:with-state (operator visual)
        (:bind "g s" #'evil-snipe-x
               "g S" #'evil-snipe-X)))
    (:with-function turn-off-evil-snipe-override-mode (:hook-into magit-mode))
    (:option evil-snipe-scope 'visible
             evil-snipe-repeat-scope 'whole-visible
             evil-snipe-spillover-scope 'whole-buffer)
    (:enable)
    (:with-mode evil-snipe-override-mode
      (:enable)))
#+end_src

**** Evil Easymotion
[[https://github.com/PythonNut/evil-easymotion][evil-easymotion]] is a Evil port of Vim's, well, =easymotion=, which basically works in a way that instead of numbering how many jumps needed, by prefixing motions with a leader key, we use visual hint to go to the place we want. I hadn't tried =easymotion= during my Vim era though, but I like it now. It also provides integration with [[*evil-snipe][evil-snipe]].
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-evil-easymotion
    (let ((commit "f96c2ed38ddc07908db7c3c11bcd6285a3e8c2e9")
          (last-release-version "20160228") ;; from the el file version header
          (revision "0")
          (url "https://github.com/PythonNut/evil-easymotion"))
      (package
       (name "emacs-evil-easymotion")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "0xsva9bnlfwfmccm38qh3yvn4jr9za5rxqn4pwxbmhnx4rk47cch"))))
       (inputs
        (list upstream:emacs-evil upstream:emacs-avy))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "A port of vim easymotion to Emacs' evil-mode")
       (description "This package gives Lokaltog/vim-easymotion a
  streak of malevolence.")
       (license license:gpl3+))))
#+end_src

#+begin_src emacs-lisp
  (setup (:require evil-easymotion)
    (:also-load evil)
    (:with-map evil-snipe-parent-transient-map
      (:bind "SPC" (evilem-create 'evil-snipe-repeat
                                  :bind ((evil-snipe-scope 'buffer)
                                         (evil-snipe-enable-highlight)
                                         (evil-snipe-enable-incremental-highlight)))))
    (:with-map my-leader-map
      (:bind "j" (evilem-create 'next-line)
               "k" (evilem-create 'previous-line)
               "n" #'evilem-motion-search-previous
               "N" #'evilem-motion-search-next)))
#+end_src

**** Evil Commentary
[[https://github.com/linktohack/evil-commentary][evil-commentary]] defines operators for commenting.
#+begin_src emacs-lisp
  (setup evil-commentary
    (:also-load evil)
    (:enable))
#+end_src
*** God mode
[[https://github.com/emacsorphanage/god-mode][god-mode]] provides a minor mode in which modifier keys of key bindings are handled sepecially: =C-= is not needed any more, =M-= is implied with a single key, etc.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-god-mode")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require god-mode)
    (:option god-mode-alist '((nil . "C-") ("m" . "M-") ("M" . "C-M-"))
             god-mode-enable-function-key-translation t)
    (:global
        (:with-state (normal visual motion)
          (:bind "SPC" #'god-execute-with-current-bindings))
      (:with-state (insert emacs motion)
        (:bind "C-<espace>" #'god-execute-with-current-bindings))))
#+end_src

*** Which key
[[https://github.com/justbur/emacs-which-key][which-key]] is a minor mode that hints you the keybindings prefixed with what you have typed when you get stuck.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-which-key")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require which-key)
    (:option which-key-show-transient-maps t)
    (which-key-enable-god-mode-support)
    (:enable))
#+end_src

*** Posframe
[[https://github.com/tumashu/posframe][posframe]] pops a child-frame at point, connected to its root window's buffer.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-posframe")))
#+end_src

*** Ace Window
[[https://github.com/abo-abo/ace-window][ace-window]] is helpful to do things the "embark" way: pick a window, then decide what to do with it.

Its package definition in the Guix official channel is for the "latest" release version, which is as old as 2014. So I makes a variation to use the master branch HEAD at the time of writing.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-ace-window-next
    (let ((commit "77115afc1b0b9f633084cf7479c767988106c196")
          (last-release-version "0.10.0")
          (revision "0"))
      (package
       (inherit upstream:emacs-ace-window)
       (name "emacs-ace-window-next")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url "https://github.com/abo-abo/ace-window")
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "1l6rp92q4crahx9nq7s6zxqyw7ccrhkl95v70vxra7zndqpqwsbq")))))))
#+end_src

#+begin_src scheme
    (simple-service
     'home-emacs-ace-window
     home-profile-service-type
     (list
      (specification->package
       "emacs-ace-window-next")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require ace-window)
    (:option aw-keys '(?u ?h ?e ?t ?i ?d ?o ?n ?a ?s)
             aw-translate-char-function (lambda (c)
                                          (pcase c
                                            (?\[ ?7)
                                            (?\{ ?5)
                                            (?\} ?3)
                                            (?\( ?1)
                                            (?= ?9)
                                            (?* ?0)
                                            (?\) ?2)
                                            (?+ ?4)
                                            (?\] ?6)
                                            (?! ?8)
                                            (_ c)))
             aw-dispatch-alist '((?Q aw-delete-window "Delete Window")
                                 (?W aw-swap-window "Swap Windows")
                                 (?M aw-move-window "Move Window")
                                 (?C aw-copy-window "Copy Window")
                                 (?J aw-switch-buffer-in-window "Select Buffer")
                                 (?D aw-use-frame "Make frame for window")
                                 (?N aw-flip-window)
                                 (?U aw-switch-buffer-other-window "Switch Buffer Other Window")
                                 (?E aw-execute-command-other-window "Execute Command Other Window")
                                 (?F aw-split-window-fair "Split Fair Window")
                                 (?S aw-split-window-vert "Split horizontally")
                                 (?V aw-split-window-horz "Split vertically")
                                 (?O delete-other-windows "Delete Other Windows")
                                 (?T aw-transpose-frame "Transpose Frame")
                                 ;; ?i ?r ?t are used by hyperbole.el
                                 (?? aw-show-dispatch-help)))
    (:global (:bind "<remap> <evil-window-next>" #'ace-window
                    "<remap> <other-window>" #'ace-window)))
#+end_src

=ace-window= has its =posframe= integration now (which is the main reason why I need more recent commits), which use it to show the keys in the centers of buffers.
#+begin_src emacs-lisp
  (setup ace-window-posframe
    (:enable))
#+end_src
*** Spell Checking
See the [[info:emacs#Spelling][documentation]] for details.

Emacs comes with a spell checking wrapper...
#+begin_src emacs-lisp
  (setup ispell
    (:needs "aspell")
    (:option ispell-program-name "aspell"))
#+end_src

... and an on-the-fly spell checker(which uses ~ispell~ as the backend).
#+begin_src emacs-lisp
  (setup flyspell
    (:needs "aspell")
    ;; (general-unbind flyspell-mode-map "C-;")
    (:unbind "C-;")
    (:hook-into text-mode)
    (:with-mode flyspell-prog-mode
      (:hook-into prog-mode)))
#+end_src

**** Flyspell Correct
The default UI for ~ispell~ is quite hard to use, and there is a package [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] that makes use of the ~completing-read~ interface to make things much more usable.
#+begin_src scheme
  (simple-service
   'home-emacs-flyspell-correct
   home-profile-service-type
   (list
    (specification->package
     "emacs-flyspell-correct")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require flyspell-correct)
    (:needs "aspell")
    (:also-load flyspell)
    (:global (:bind "<remap> <ispell-word>" #'flyspell-correct-wrapper)))
#+end_src

*** Topsy
[[https://github.com/alphapapa/topsy.el][topsy]] shows a sticky header at the top of the window, displaying which function is the one that extends to the lines before the top of the displayed buffer.
#+begin_src scheme :tangle "build/hiecaq/packages/emacs-xyz.scm" :noweb-ref nil
  (define-public emacs-topsy
    (let ((commit "8ae0976dfdbe4461c33ed44cf1dedc2c903b0bb0")
          (last-release-version "0.1-pre") ;; from the el file version header
          (revision "0")
          (url "https://github.com/alphapapa/topsy.el"))
      (package
       (name "emacs-topsy")
       (version (git-version last-release-version revision commit))
       (source
        (origin
         (method git-fetch)
         (uri (git-reference
               (url url)
               (commit commit)))
         (file-name (git-file-name name version))
         (sha256
          (base32
           "032i1prl2v5w4l37zjlqam7063s56nk61nj5l3ypmxp98yz9nrq8"))))
       (build-system emacs-build-system)
       (home-page url)
       (synopsis "Simple sticky header showing definition beyond top of window")
       (description "This library shows a sticky header at the top of the window.
  The header shows which definition the top line of the window is within. ")
       (license license:gpl3))))
#+end_src

#+begin_src emacs-lisp
  (setup topsy
    (:hook-into prog-mode))
#+end_src

#+begin_src scheme
    (simple-service
     'home-emacs-topsy
     home-profile-service-type
     (list
      (specification->package
       "emacs-topsy")))
#+end_src

*** Orderless
 [[https://github.com/oantolin/orderless][orderless]] add space-separated component (which then matches against several matching styles) completion style to minibuffer and other completion UI.
#+begin_src scheme
  (simple-service
   'home-emacs-orderless
   home-profile-service-type
   (list
    (specification->package
     "emacs-orderless")))
#+end_src

#+begin_src emacs-lisp
  (setup orderless
    (:option completion-category-defaults nil)
    ;; see https://www.reddit.com/r/emacs/comments/ns5jfu/defmacro_and_nested_backquotes_confusion/
    (defmacro my-orderless--dispatch-prefix-def (prefix style)
      `(defun ,(intern (format "my-%s-prefix" (symbol-name (eval style)))) (pattern _index _total)
         (cond
          ((equal ,prefix pattern)
           '(orderless-literal . ""))
          ((string-prefix-p ,prefix pattern)
           (cons ,style  (substring pattern 1))))))
    (my-orderless--dispatch-prefix-def "$" 'orderless-regexp)
    (my-orderless--dispatch-prefix-def "=" 'orderless-literal)
    (my-orderless--dispatch-prefix-def "!" 'orderless-without-literal)
    (my-orderless--dispatch-prefix-def "-" 'orderless-prefixes)
    (my-orderless--dispatch-prefix-def "'" 'orderless-initialism)
    (my-orderless--dispatch-prefix-def ";" 'orderless-flex)
    (:option orderless-component-separator 'orderless-escapable-split-on-space
             completion-styles '(orderless basic)
             completion-category-overrides '((file (styles basic partial-completion)))
             orderless-matching-styles '(orderless-regexp)
             orderless-style-dispatchers '(my-orderless-regexp-prefix
                                           my-orderless-literal-prefix
                                           my-orderless-without-literal-prefix
                                           my-orderless-prefixes-prefix
                                           my-orderless-initialism-prefix
                                           my-orderless-flex-prefix)))
#+end_src
*** Vertico
[[https://github.com/minad/vertico][vertico]] "provides a performant and minimalistic vertical completion UI based on the default completion system."
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-vertico")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require vertico)
    (:enable))
#+end_src

*** Marginalia
[[https://github.com/minad/marginalia][marginalia]] adds info to the right of completion candidates, thus the name margin-alia.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-marginalia")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require marginalia)
    (:enable))
#+end_src

*** Consult
[[https://github.com/minad/consult][consult]] provides practical commands based on the Emacs completion function =completing-read=. What this means is that basically =consult= pop up candidates when calling its commands into =comleting-read=.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-consult")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require consult)
    (:option consult-preview-key "\C-j"
             xref-show-definitions-function #'consult-xref
             xref-show-xrefs-function #'consult-xref)
    (:with-map my-leader-map
      (:bind
       "h b" #'consult-buffer
       "h s" (lambda ()
               (interactive)
               (let ((current-prefix-arg '(4)))
                 (call-interactively #'consult-ripgrep)))
       "h l" #'consult-flymake
       "h f" #'consult-find
       "h F" #'consult-locate
       "h i" #'consult-imenu
       "h o" #'consult-outline
       "h m" #'consult-minor-mode-menu
       "h x" #'consult-mode-command
       "h k" #'consult-man)))
#+end_src

*** Embark
[[https://github.com/oantolin/embark][embark]] is probably the most world-changing package in Emacs recently. It basically provides a just-in-time context-aware action list (quite like no-repeating hydra or which-key) in minibuffer on the =complete-read= candidate or on anything in the editing file.

Reference:
- [[https://github.com/oantolin/embark/wiki][wiki]]
- [[https://karthinks.com/software/fifteen-ways-to-use-embark/][15 ways to use embark]]

#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-embark")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require embark)
    ;; Optionally replace the key help with a completing-read interface
    (:option prefix-help-command #'embark-prefix-help-command)
    (:option embark-cycle-key (kbd "C-'"))

    ;; adapted from https://karthinks.com/software/fifteen-ways-to-use-embark/
    (defmacro my-embark-ace-action (fn)
      `(defun ,(intern (concat "my-embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn))))))
    (my-embark-ace-action find-file)
    (my-embark-ace-action switch-to-buffer)
    (my-embark-ace-action bookmark-jump)

    (:with-map minibuffer-local-map (:bind "C-'" #'embark-act))
    (:global (:bind "C-h B" #'embark-bindings) ;; alternative for `describe-bindings'
      (:with-state (normal visual)
        (:bind "g a" #'embark-act
               "g A" #'embark-dwim)))
    (:with-map embark-file-map (:bind "o" #'my-embark-ace-find-file))
    (:with-map embark-buffer-map (:bind "o" #'my-embark-ace-switch-to-buffer))
    (:with-map embark-bookmark-map (:bind "o" #'my-embark-ace-bookmark-jump)))
#+end_src

#+begin_src emacs-lisp
  (setup (:require embark-consult))
#+end_src
*** corfu
[[https://github.com/minad/corfu][corfu]] is a ~completion-at-point~ implementation that is much more concise than =company=.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-corfu")))
#+end_src

#+begin_src emacs-lisp :noweb yes
  (setup corfu
    (:option corfu-preview-current nil
             corfu-quit-at-boundary nil)
    (:option tab-always-indent 'complete)
    (:with-state (insert emacs)
      (:global (:bind "<CTRL-i>" #'completion-at-point)) ;; see early-init.el
      (:with-map corfu-map (:bind "<escape>" #'corfu-reset
                                  "SPC" #'corfu-insert-separator)))
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active)
                  (bound-and-true-p vertico--input))
        (:enable)))
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
    (:require corfu)
    (:with-mode global-corfu-mode (:enable)))
#+end_src


*** Visual Undo
[[https://github.com/casouri/vundo][vundo]] is basically a less-buggy [[https://www.dr-qubit.org/undo-tree.html][undo-tree]] that supports Emacs 28's new ~undo-redo~.
#+begin_src scheme
  (simple-service
   'home-emacs-vundo
   home-profile-service-type
   (list
    (specification->package
     "emacs-vundo")))
#+end_src

#+begin_src emacs-lisp
  (setup (:require vundo)
    (:with-map my-leader-map (:bind "u" #'vundo)))
#+end_src

*** Hideshow
[[info:emacs#Hideshow][hideshow]] is Emacs' built-in code folding package.
#+begin_src emacs-lisp
  (setup hideshow
    (:with-mode hs-minor-mode (:hook-into prog-mode)))
#+end_src

*** electric-pair-mode
=electric-pair-mode= is a built-in package that auto insert the left bracket/parentheses when we type the left one. It also skip the right bracket/parentheses if we type it. This behavior might be familiar to many IDE users.
#+begin_src emacs-lisp
  (setup elec-pair
    (:with-mode electric-pair-local-mode
      (:hook-into emacs-lisp-mode scheme-mode)))
#+end_src

*** Aggresive Indent
[[https://github.com/Malabarba/aggressive-indent-mode][aggressize-indent-mode]] basically reindents what you have changed after every change you made.
#+begin_src scheme
  (simple-service
   'home-emacs-setup
   home-profile-service-type
   (list
    (specification->package
     "emacs-aggressive-indent")))
#+end_src

#+begin_src emacs-lisp
  (setup aggressive-indent
    (:hook-into emacs-lisp-mode scheme-mode)
    (:option aggressive-indent-dont-indent-if '((evil-insert-state-p) (evil-replace-state-p)))
    (defun my-aggressive-indent-after-change ()
      (cond (aggressive-indent-mode
             (add-hook 'evil-normal-state-entry-hook #'aggressive-indent--process-changed-list-and-indent nil t))
            (t
             (remove-hook 'evil-normal-state-entry-hook #'aggressive-indent--process-changed-list-and-indent nil t))))
    (:hook #'my-aggressive-indent-after-change))
#+end_src

*** Magit
[[https://github.com/magit/magit][magit]] is an Emacs interface to git, which provides not only commands to call but also a full GUI-like wrapper around git.
#+begin_src scheme
  (simple-service
   'home-emacs-magit
   home-profile-service-type
   (list
    (specification->package
     "emacs-magit")))
#+end_src

#+begin_src emacs-lisp
  (setup magit
    (:option magit-display-buffer-function #'display-buffer
             magit-bury-buffer-function #'quit-window ;; play nice with shackle
             evil-collection-magit-use-z-for-folds t
             magit-bind-magit-project-status nil))
#+end_src

Its Evil integration is now a part of evil-collection.

*** Org Mode
From its website
#+begin_quote
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system.
#+end_quote
this is only a facial overall summary of what [[https://orgmode.org][org-mode]] is usually used for. It is so powerful that It is one of the reasons I switched from Neovim to Emacs.

#+begin_src scheme
  (simple-service
   'home-emacs-org
   home-profile-service-type
   (specifications->packages
    (list "emacs-org"
          "emacs-toc-org")))
#+end_src

#+begin_src emacs-lisp
  (setup org
    (:hook visual-line-mode variable-pitch-mode))
#+end_src

**** Toc Org
[[https://github.com/snosov1/toc-org][toc-org]] will automatically update the content of the first heading with a =:TOC:= tag in an org file to show an up-to-date TOC whenever the file is saved. Handy!
#+begin_src emacs-lisp
  (setup toc-org
    (:also-load org)
    (:hook-into org-mode))
#+end_src

* References and Recommendations
This configuration is written while referencing the following guix configurations:
- [[https://git.sr.ht/~akagi/guixrc][Aleksandr Vityazev's Guix Configuration]]
- [[https://github.com/dustinlyons/guix-config][Dustin Lyon's Literate Configuration for Guix Linux]]
- [[https://git.envs.net/iyzsong/guixrc.git][iyzsong's Guix System and Home Config]]
- [[https://git.sr.ht/~krevedkokun/dotfiles][Nikita Domnitskii's Dotfiles]]
- [[https://github.com/nicolas-graves/dotfiles][Nicolas Graves's Dotfiles]]
- [[https://github.com/qbladea/linux-os][Luhux 的 Guix 操作系统配置文件]]
- [[https://git.sr.ht/~abcdw/rde][rde by Andrew Tropin]]. I use it as a channel.
- [[https://github.com/tumashu/geeguix][Tumashu's Guixsd Configuration]]
